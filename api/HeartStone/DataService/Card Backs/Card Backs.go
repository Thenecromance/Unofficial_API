package HeartStone_Card Backs
// AUTOMATICALLY GENERATED FILE, DO NOT EDIT
// This file is generated by tools/updater
// Author: @Thenecromance 
import (
	"Unofficial_API/api/Authentication"
	"Unofficial_API/utils"
	"context"
	"encoding/json"
	"io"
	"net/http"
	"strconv"
)

 
//==============================================================================================

type CardBackSearchFields struct{
	Locale string//The locale to reflect in localized data. If you do not supply a value, all translations are returned.
	CardBackCategory string//A category of the card back. The category must match a valid category.
	TextFilter string//A text string used to filter card backs. You must include a locale along with the textFilter parameter.
	Sort string//The field used to sort the results. Valid value include name:asc, name:desc, dateAdded:asc, and dateAdded:desc. Results are sorted by date (desc) by default.
	Page int//A page number.
	PageSize int//The number of results to choose per page. A value will be selected automatically if you do not supply a pageSize or if the pageSize is higher than the maximum allowed.
	Order (Deprecated) string//The order in which to sort the results if no order is provided with sort option. Valid values are asc or desc. The default value is asc.
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func CardBackSearchField(input *CardBackSearchFields) *CardBackSearchFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/hearthstone/cardbacks",
//			CnRegion:false ,
//}
//return input
//}


//CardBackSearch Returns an up-to-date list of all card backs matching the search criteria. For more information about the search parameters, see the <a href='/documentation/hearthstone/guides/card-backs'>Card Backs Guide</a>.
//
//@see: /hearthstone/cardbacks
func StringCardBackSearch(ctx context.Context, fields *CardBackSearchFields)(string,error){
	if fields == nil {
		fields = &CardBackSearchFields{}
	}

	func(input *CardBackSearchFields) {
	
if input.Locale==""{
input.Locale = "<no value>"
}

	
if input.CardBackCategory==""{
input.CardBackCategory = "<no value>"
}

	
if input.TextFilter==""{
input.TextFilter = "<no value>"
}

	
if input.Sort==""{
input.Sort = "dateAdded:desc"
}

	
if input.Page==0{
input.Page = <no value>
}
	
	
if input.PageSize==0{
input.PageSize = <no value>
}
	
	
if input.Order (Deprecated)==""{
input.Order (Deprecated) = "desc"
}

	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/hearthstone/cardbacks",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("locale", fields.Locale)
	q.Add("cardBackCategory", fields.CardBackCategory)
	q.Add("textFilter", fields.TextFilter)
	q.Add("sort", fields.Sort)
	q.Add("page", strconv.Itoa(fields.Page))
	q.Add("pageSize", strconv.Itoa(fields.PageSize))
	q.Add("order (deprecated)", fields.Order (Deprecated))
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNCardBackSearch(ctx context.Context, fields *CardBackSearchFields)(any,error){

obj, err := StringCardBackSearch(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&CardBackSearchResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var CardBackSearch = CNCardBackSearch
/*func BNetCardBackSearch(ctx context.Context, fields *CardBackSearchFields)(any,error){

obj ,err := CNCardBackSearch(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*CardBackSearchResponse).ToBNet(),nil
}*/

 
//==============================================================================================

type FetchonecardbackFields struct{
	Idorslug string//An ID or slug that uniquely identifies a card back. You can discover these values by using the GET /hearthstone/cardbacks endpoint
	Locale string//The locale to reflect in localized data. If you do not supply a value, all translations are returned.
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func FetchonecardbackField(input *FetchonecardbackFields) *FetchonecardbackFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/hearthstone/cardbacks/:idorslug",
//			CnRegion:false ,
//}
//return input
//}


//Fetchonecardback Returns a specific card back by using card back ID or slug.
//
//@see: /hearthstone/cardbacks/:idorslug
func StringFetchonecardback(ctx context.Context, fields *FetchonecardbackFields)(string,error){
	if fields == nil {
		fields = &FetchonecardbackFields{}
	}

	func(input *FetchonecardbackFields) {
	
if input.Idorslug==""{
input.Idorslug = "155-pizza-stone"
}

	
if input.Locale==""{
input.Locale = "<no value>"
}

	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/hearthstone/cardbacks/:idorslug",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("idorslug", fields.Idorslug)
	q.Add("locale", fields.Locale)
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNFetchonecardback(ctx context.Context, fields *FetchonecardbackFields)(any,error){

obj, err := StringFetchonecardback(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&FetchonecardbackResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var Fetchonecardback = CNFetchonecardback
/*func BNetFetchonecardback(ctx context.Context, fields *FetchonecardbackFields)(any,error){

obj ,err := CNFetchonecardback(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*FetchonecardbackResponse).ToBNet(),nil
}*/


