package HeartStone_Metadata

// AUTOMATICALLY GENERATED FILE, DO NOT EDIT
// This file is generated by tools/updater
// Author: @Thenecromance

import (
	"context"
	"encoding/json"
	

	

	"io"
	"net/http"

	"Unofficial_API/ApiError"
	"Unofficial_API/api/Authentication"
	"Unofficial_API/global"
	"Unofficial_API/utils"


	"github.com/jtacoma/uritemplates"

)


// ==============================================================================================
// API: Allmetadata
// ==============================================================================================

type AllmetadataFields struct {
	Locale string `form:"locale,default=en_US"` // The locale to reflect in localized data.

	// Extra fields for internal logic
	ExtraFields map[any]any
	CN          *utils.CNRequestMethod
	utils.RequestMethod
}

// CNHookAllmetadata allows injecting a custom implementation for the CN endpoint.
// Implement this in a separate file (e.g. init()) to handle CN logic without modifying generated code.
var CNHookAllmetadata func(context.Context, *AllmetadataFields) (any, error)

// StringAllmetadata executes the request and returns the raw response body string.
func StringAllmetadata(ctx context.Context, fields *AllmetadataFields) (string, error) {
	if fields == nil {
		fields = &AllmetadataFields{}
	}

	// 1. Initialize Request Metadata
	fields.RequestMethod = utils.GetApiConfig("Allmetadata")
	if fields.RequestMethod.Path == "" {
		fields.RequestMethod = utils.RequestMethod{
			Methods:  "GET",
			Path:     "/hearthstone/metadata",
			CnRegion: false,
		}
	}

	// 2. Apply Default Values (if needed for client-side logic)
	// Note: Usually struct tags handle server-side binding,
	// but here we might need manual checks if 0/"" are invalid for the request.
	
	if fields.Locale == "" {
		fields.Locale = "en_US"
	}
	
	

	// 3. Create HTTP Request
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		global.PortalURL, // Base URL will be joined with Path below
		nil,
	)
	if err != nil {
		return "", err
	}

	// Add Auth Header
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())

	// 4. Resolve Path (Handle URI Bindings)
	{
	
    	req.URL.Path = fields.Path
    	
	}

	// 5. Build Query Strings
{
	q := req.URL.Query()


	for key, value := range fields.ExtraFields {
		q.Add(key.(string), value.(string))
	}

	
    
	if !q.Has("locale") {
		q.Add("locale", "en_US")
	}
    


	req.URL.RawQuery = q.Encode()
}

	// 6. Execute Request
	cli := http.Client{}
	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

// bridgeAllmetadata routes the request to either CN or Global logic based on input.
func bridgeAllmetadata(ctx context.Context, fields *AllmetadataFields) (any, error) {
    

	// 1. If CN specific parameters are present, use CN logic
	if fields.CN != nil {
        // Design Scheme: Check if a custom CN handler is registered at runtime.
		// This allows extension without modifying the template generator.
		if CNHookAllmetadata != nil {
			return CNHookAllmetadata(ctx, fields)
		}

		return nil, ApiError.ErrorNotSupported
	}

	// 2. Default: Use Global/Standard logic
	objString, err := StringAllmetadata(ctx, fields)
	if err != nil {
		return nil, err
	}

	resp := &AllmetadataModel{}
	if err = json.Unmarshal([]byte(objString), &resp); err != nil {
		return nil, err
	}

	return resp, nil
}

// Allmetadata
/* Allmetadata Returns information about the categorization of cards. Metadata includes the card set, set group (for example, Standard or Year of the Dragon), rarity, class, card type, minion type, and keywords. For more information, see the <a href='/documentation/hearthstone/guides/metadata'>Metadata Guide</a>. */
// Path: /hearthstone/metadata
var Allmetadata = bridgeAllmetadata


// ==============================================================================================
// API: Specificmetadata
// ==============================================================================================

type SpecificmetadataFields struct {
	Locale string `form:"locale,default=en_US"` // The locale to reflect in localized data.
	Type string `uri:"type" binding:"required"` // The type of the metadata to retrieve. Valid values include sets, setGroups, types, rarities, classes, minionTypes, and keywords.
	
	// Extra fields for internal logic
	ExtraFields map[any]any
	CN          *utils.CNRequestMethod
	utils.RequestMethod
}

// CNHookSpecificmetadata allows injecting a custom implementation for the CN endpoint.
// Implement this in a separate file (e.g. init()) to handle CN logic without modifying generated code.
var CNHookSpecificmetadata func(context.Context, *SpecificmetadataFields) (any, error)

// StringSpecificmetadata executes the request and returns the raw response body string.
func StringSpecificmetadata(ctx context.Context, fields *SpecificmetadataFields) (string, error) {
	if fields == nil {
		fields = &SpecificmetadataFields{}
	}

	// 1. Initialize Request Metadata
	fields.RequestMethod = utils.GetApiConfig("Specificmetadata")
	if fields.RequestMethod.Path == "" {
		fields.RequestMethod = utils.RequestMethod{
			Methods:  "GET",
			Path:     "/hearthstone/metadata/:type",
			CnRegion: false,
		}
	}

	// 2. Apply Default Values (if needed for client-side logic)
	// Note: Usually struct tags handle server-side binding,
	// but here we might need manual checks if 0/"" are invalid for the request.
	
	if fields.Locale == "" {
		fields.Locale = "en_US"
	}
	
	
	if fields.Type == "" {
		fields.Type = "sets"
	}
	
	

	// 3. Create HTTP Request
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		global.PortalURL, // Base URL will be joined with Path below
		nil,
	)
	if err != nil {
		return "", err
	}

	// Add Auth Header
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())

	// 4. Resolve Path (Handle URI Bindings)
	{
	
    	tpl, err := uritemplates.Parse(fields.Path)
    	if err != nil {
    		return "", err
    	}

    	pathValues := map[string]interface{}{
    		"type": fields.Type,
    		
    	}

    	expandedPath, err := tpl.Expand(pathValues)
    	if err != nil {
    		return "", err
    	}
    	req.URL.Path = expandedPath
    	
	}

	// 5. Build Query Strings
{
	q := req.URL.Query()


	for key, value := range fields.ExtraFields {
		q.Add(key.(string), value.(string))
	}

	
    
	if !q.Has("locale") {
		q.Add("locale", "en_US")
	}
    


	req.URL.RawQuery = q.Encode()
}

	// 6. Execute Request
	cli := http.Client{}
	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

// bridgeSpecificmetadata routes the request to either CN or Global logic based on input.
func bridgeSpecificmetadata(ctx context.Context, fields *SpecificmetadataFields) (any, error) {
    

	// 1. If CN specific parameters are present, use CN logic
	if fields.CN != nil {
        // Design Scheme: Check if a custom CN handler is registered at runtime.
		// This allows extension without modifying the template generator.
		if CNHookSpecificmetadata != nil {
			return CNHookSpecificmetadata(ctx, fields)
		}

		return nil, ApiError.ErrorNotSupported
	}

	// 2. Default: Use Global/Standard logic
	objString, err := StringSpecificmetadata(ctx, fields)
	if err != nil {
		return nil, err
	}

	resp := &SpecificmetadataModel{}
	if err = json.Unmarshal([]byte(objString), &resp); err != nil {
		return nil, err
	}

	return resp, nil
}

// Specificmetadata
/* Specificmetadata Returns information about just one type of metadata. For more information, see the <a href='/documentation/hearthstone/guides/metadata'>Metadata Guide</a>. */
// Path: /hearthstone/metadata/:type
var Specificmetadata = bridgeSpecificmetadata

