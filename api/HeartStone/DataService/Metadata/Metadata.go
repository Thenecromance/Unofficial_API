package HeartStone_Metadata

// AUTOMATICALLY GENERATED FILE, DO NOT EDIT
// This file is generated by tools/updater
// Author: @Thenecromance
import (
	"Unofficial_API/api/Authentication"
	"Unofficial_API/utils"
	"context"
	"encoding/json"
	"io"
	"net/http"
)

//==============================================================================================

type AllmetadataFields struct {
	Locale string //The locale to reflect in localized data.

	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func AllmetadataField(input *AllmetadataFields) *AllmetadataFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/hearthstone/metadata",
//			CnRegion:false ,
//}
//return input
//}

// Allmetadata Returns information about the categorization of cards. Metadata includes the card set, set group (for example, Standard or Year of the Dragon), rarity, class, card type, minion type, and keywords. For more information, see the <a href='/documentation/hearthstone/guides/metadata'>Metadata Guide</a>.
//
// @see: /hearthstone/metadata
func StringAllmetadata(ctx context.Context, fields *AllmetadataFields) (string, error) {
	if fields == nil {
		fields = &AllmetadataFields{}
	}

	func(input *AllmetadataFields) {

		if input.Locale == "" {
			input.Locale = "en_US"
		}

		input.RequestMethod = utils.RequestMethod{
			Methods:  "GET",
			Path:     "/hearthstone/metadata",
			CnRegion: false,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)

	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("locale", fields.Locale)

	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNAllmetadata(ctx context.Context, fields *AllmetadataFields) (any, error) {

	obj, err := StringAllmetadata(ctx, fields)
	if err != nil {
		return nil, err
	}
	resp := &AllmetadataResponse{}
	err = json.Unmarshal([]byte(obj), resp)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

var Allmetadata = CNAllmetadata

/*func BNetAllmetadata(ctx context.Context, fields *AllmetadataFields)(any,error){

obj ,err := CNAllmetadata(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*AllmetadataResponse).ToBNet(),nil
}*/

//==============================================================================================

type SpecificmetadataFields struct {
	Locale string //The locale to reflect in localized data.
	Type   string //The type of the metadata to retrieve. Valid values include sets, setGroups, types, rarities, classes, minionTypes, and keywords.

	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func SpecificmetadataField(input *SpecificmetadataFields) *SpecificmetadataFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/hearthstone/metadata/:type",
//			CnRegion:false ,
//}
//return input
//}

// Specificmetadata Returns information about just one type of metadata. For more information, see the <a href='/documentation/hearthstone/guides/metadata'>Metadata Guide</a>.
//
// @see: /hearthstone/metadata/:type
func StringSpecificmetadata(ctx context.Context, fields *SpecificmetadataFields) (string, error) {
	if fields == nil {
		fields = &SpecificmetadataFields{}
	}

	func(input *SpecificmetadataFields) {

		if input.Locale == "" {
			input.Locale = "en_US"
		}

		if input.Type == "" {
			input.Type = "sets"
		}

		input.RequestMethod = utils.RequestMethod{
			Methods:  "GET",
			Path:     "/hearthstone/metadata/:type",
			CnRegion: false,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)

	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("locale", fields.Locale)
	q.Add("type", fields.Type)

	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNSpecificmetadata(ctx context.Context, fields *SpecificmetadataFields) (any, error) {

	obj, err := StringSpecificmetadata(ctx, fields)
	if err != nil {
		return nil, err
	}
	resp := &SpecificmetadataResponse{}
	err = json.Unmarshal([]byte(obj), resp)
	if err != nil {
		return nil, err
	}

	return resp, nil
}

var Specificmetadata = CNSpecificmetadata

/*func BNetSpecificmetadata(ctx context.Context, fields *SpecificmetadataFields)(any,error){

obj ,err := CNSpecificmetadata(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*SpecificmetadataResponse).ToBNet(),nil
}*/
