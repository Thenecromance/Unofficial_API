package wowRetail_Quest
// AUTOMATICALLY GENERATED FILE, DO NOT EDIT
// This file is generated by tools/updater
// Author: @Thenecromance 
import (
	"Unofficial_API/api/Authentication"
	"Unofficial_API/utils"
	"context"
	"encoding/json"
	"io"
	"net/http"
	"strconv"
)

 
//==============================================================================================

type QuestsIndexFields struct{
	Namespace string//The namespace to use to locate this document.
	Locale string//The locale to reflect in localized data.
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func QuestsIndexField(input *QuestsIndexFields) *QuestsIndexFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/data/wow/quest/index",
//			CnRegion:false ,
//}
//return input
//}


//QuestsIndex Returns the parent index for quests.
//
//@see: /data/wow/quest/index
func StringQuestsIndex(ctx context.Context, fields *QuestsIndexFields)(string,error){
	if fields == nil {
		fields = &QuestsIndexFields{}
	}

	func(input *QuestsIndexFields) {
	
if input.Namespace==""{
input.Namespace = "static-us"
}

	
if input.Locale==""{
input.Locale = "en_US"
}

	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/data/wow/quest/index",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("namespace", fields.Namespace)
	q.Add("locale", fields.Locale)
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNQuestsIndex(ctx context.Context, fields *QuestsIndexFields)(any,error){

obj, err := StringQuestsIndex(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&QuestsIndexResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var QuestsIndex = CNQuestsIndex
/*func BNetQuestsIndex(ctx context.Context, fields *QuestsIndexFields)(any,error){

obj ,err := CNQuestsIndex(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*QuestsIndexResponse).ToBNet(),nil
}*/

 
//==============================================================================================

type QuestFields struct{
	QuestId int//The ID of the quest.
	Namespace string//The namespace to use to locate this document.
	Locale string//The locale to reflect in localized data.
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func QuestField(input *QuestFields) *QuestFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/data/wow/quest/{questId}",
//			CnRegion:false ,
//}
//return input
//}


//Quest Returns a quest by ID.
//
//@see: /data/wow/quest/{questId}
func StringQuest(ctx context.Context, fields *QuestFields)(string,error){
	if fields == nil {
		fields = &QuestFields{}
	}

	func(input *QuestFields) {
	
if input.QuestId==0{
input.QuestId = 2
}
	
	
if input.Namespace==""{
input.Namespace = "static-us"
}

	
if input.Locale==""{
input.Locale = "en_US"
}

	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/data/wow/quest/{questId}",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("questId", strconv.Itoa(fields.QuestId))
	q.Add("namespace", fields.Namespace)
	q.Add("locale", fields.Locale)
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNQuest(ctx context.Context, fields *QuestFields)(any,error){

obj, err := StringQuest(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&QuestResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var Quest = CNQuest
/*func BNetQuest(ctx context.Context, fields *QuestFields)(any,error){

obj ,err := CNQuest(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*QuestResponse).ToBNet(),nil
}*/

 
//==============================================================================================

type QuestCategoriesIndexFields struct{
	Namespace string//The namespace to use to locate this document.
	Locale string//The locale to reflect in localized data.
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func QuestCategoriesIndexField(input *QuestCategoriesIndexFields) *QuestCategoriesIndexFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/data/wow/quest/category/index",
//			CnRegion:false ,
//}
//return input
//}


//QuestCategoriesIndex Returns an index of quest categories (such as quests for a specific class, profession, or storyline).
//
//@see: /data/wow/quest/category/index
func StringQuestCategoriesIndex(ctx context.Context, fields *QuestCategoriesIndexFields)(string,error){
	if fields == nil {
		fields = &QuestCategoriesIndexFields{}
	}

	func(input *QuestCategoriesIndexFields) {
	
if input.Namespace==""{
input.Namespace = "static-us"
}

	
if input.Locale==""{
input.Locale = "en_US"
}

	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/data/wow/quest/category/index",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("namespace", fields.Namespace)
	q.Add("locale", fields.Locale)
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNQuestCategoriesIndex(ctx context.Context, fields *QuestCategoriesIndexFields)(any,error){

obj, err := StringQuestCategoriesIndex(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&QuestCategoriesIndexResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var QuestCategoriesIndex = CNQuestCategoriesIndex
/*func BNetQuestCategoriesIndex(ctx context.Context, fields *QuestCategoriesIndexFields)(any,error){

obj ,err := CNQuestCategoriesIndex(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*QuestCategoriesIndexResponse).ToBNet(),nil
}*/

 
//==============================================================================================

type QuestCategoryFields struct{
	QuestCategoryId string//The ID of the quest category.
	Namespace string//The namespace to use to locate this document.
	Locale string//The locale to reflect in localized data.
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func QuestCategoryField(input *QuestCategoryFields) *QuestCategoryFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/data/wow/quest/category/{questCategoryId}",
//			CnRegion:false ,
//}
//return input
//}


//QuestCategory Returns a quest category by ID.
//
//@see: /data/wow/quest/category/{questCategoryId}
func StringQuestCategory(ctx context.Context, fields *QuestCategoryFields)(string,error){
	if fields == nil {
		fields = &QuestCategoryFields{}
	}

	func(input *QuestCategoryFields) {
	
if input.QuestCategoryId==""{
input.QuestCategoryId = "1"
}

	
if input.Namespace==""{
input.Namespace = "static-us"
}

	
if input.Locale==""{
input.Locale = "en_US"
}

	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/data/wow/quest/category/{questCategoryId}",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("questCategoryId", fields.QuestCategoryId)
	q.Add("namespace", fields.Namespace)
	q.Add("locale", fields.Locale)
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNQuestCategory(ctx context.Context, fields *QuestCategoryFields)(any,error){

obj, err := StringQuestCategory(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&QuestCategoryResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var QuestCategory = CNQuestCategory
/*func BNetQuestCategory(ctx context.Context, fields *QuestCategoryFields)(any,error){

obj ,err := CNQuestCategory(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*QuestCategoryResponse).ToBNet(),nil
}*/

 
//==============================================================================================

type QuestAreasIndexFields struct{
	Namespace string//The namespace to use to locate this document.
	Locale string//The locale to reflect in localized data.
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func QuestAreasIndexField(input *QuestAreasIndexFields) *QuestAreasIndexFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/data/wow/quest/area/index",
//			CnRegion:false ,
//}
//return input
//}


//QuestAreasIndex Returns an index of quest areas.
//
//@see: /data/wow/quest/area/index
func StringQuestAreasIndex(ctx context.Context, fields *QuestAreasIndexFields)(string,error){
	if fields == nil {
		fields = &QuestAreasIndexFields{}
	}

	func(input *QuestAreasIndexFields) {
	
if input.Namespace==""{
input.Namespace = "static-us"
}

	
if input.Locale==""{
input.Locale = "en_US"
}

	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/data/wow/quest/area/index",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("namespace", fields.Namespace)
	q.Add("locale", fields.Locale)
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNQuestAreasIndex(ctx context.Context, fields *QuestAreasIndexFields)(any,error){

obj, err := StringQuestAreasIndex(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&QuestAreasIndexResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var QuestAreasIndex = CNQuestAreasIndex
/*func BNetQuestAreasIndex(ctx context.Context, fields *QuestAreasIndexFields)(any,error){

obj ,err := CNQuestAreasIndex(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*QuestAreasIndexResponse).ToBNet(),nil
}*/

 
//==============================================================================================

type QuestAreaFields struct{
	QuestAreaId string//The ID of the quest area.
	Namespace string//The namespace to use to locate this document.
	Locale string//The locale to reflect in localized data.
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func QuestAreaField(input *QuestAreaFields) *QuestAreaFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/data/wow/quest/area/{questAreaId}",
//			CnRegion:false ,
//}
//return input
//}


//QuestArea Returns a quest area by ID.
//
//@see: /data/wow/quest/area/{questAreaId}
func StringQuestArea(ctx context.Context, fields *QuestAreaFields)(string,error){
	if fields == nil {
		fields = &QuestAreaFields{}
	}

	func(input *QuestAreaFields) {
	
if input.QuestAreaId==""{
input.QuestAreaId = "1"
}

	
if input.Namespace==""{
input.Namespace = "static-us"
}

	
if input.Locale==""{
input.Locale = "en_US"
}

	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/data/wow/quest/area/{questAreaId}",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("questAreaId", fields.QuestAreaId)
	q.Add("namespace", fields.Namespace)
	q.Add("locale", fields.Locale)
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNQuestArea(ctx context.Context, fields *QuestAreaFields)(any,error){

obj, err := StringQuestArea(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&QuestAreaResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var QuestArea = CNQuestArea
/*func BNetQuestArea(ctx context.Context, fields *QuestAreaFields)(any,error){

obj ,err := CNQuestArea(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*QuestAreaResponse).ToBNet(),nil
}*/

 
//==============================================================================================

type QuestTypesIndexFields struct{
	Namespace string//The namespace to use to locate this document.
	Locale string//The locale to reflect in localized data.
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func QuestTypesIndexField(input *QuestTypesIndexFields) *QuestTypesIndexFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/data/wow/quest/type/index",
//			CnRegion:false ,
//}
//return input
//}


//QuestTypesIndex Returns an index of quest types (such as PvP quests, raid quests, or account quests).
//
//@see: /data/wow/quest/type/index
func StringQuestTypesIndex(ctx context.Context, fields *QuestTypesIndexFields)(string,error){
	if fields == nil {
		fields = &QuestTypesIndexFields{}
	}

	func(input *QuestTypesIndexFields) {
	
if input.Namespace==""{
input.Namespace = "static-us"
}

	
if input.Locale==""{
input.Locale = "en_US"
}

	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/data/wow/quest/type/index",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("namespace", fields.Namespace)
	q.Add("locale", fields.Locale)
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNQuestTypesIndex(ctx context.Context, fields *QuestTypesIndexFields)(any,error){

obj, err := StringQuestTypesIndex(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&QuestTypesIndexResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var QuestTypesIndex = CNQuestTypesIndex
/*func BNetQuestTypesIndex(ctx context.Context, fields *QuestTypesIndexFields)(any,error){

obj ,err := CNQuestTypesIndex(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*QuestTypesIndexResponse).ToBNet(),nil
}*/

 
//==============================================================================================

type QuestTypeFields struct{
	QuestTypeId string//The ID of the quest type.
	Namespace string//The namespace to use to locate this document.
	Locale string//The locale to reflect in localized data.
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func QuestTypeField(input *QuestTypeFields) *QuestTypeFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/data/wow/quest/type/{questTypeId}",
//			CnRegion:false ,
//}
//return input
//}


//QuestType Returns a quest type by ID.
//
//@see: /data/wow/quest/type/{questTypeId}
func StringQuestType(ctx context.Context, fields *QuestTypeFields)(string,error){
	if fields == nil {
		fields = &QuestTypeFields{}
	}

	func(input *QuestTypeFields) {
	
if input.QuestTypeId==""{
input.QuestTypeId = "1"
}

	
if input.Namespace==""{
input.Namespace = "static-us"
}

	
if input.Locale==""{
input.Locale = "en_US"
}

	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/data/wow/quest/type/{questTypeId}",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("questTypeId", fields.QuestTypeId)
	q.Add("namespace", fields.Namespace)
	q.Add("locale", fields.Locale)
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNQuestType(ctx context.Context, fields *QuestTypeFields)(any,error){

obj, err := StringQuestType(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&QuestTypeResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var QuestType = CNQuestType
/*func BNetQuestType(ctx context.Context, fields *QuestTypeFields)(any,error){

obj ,err := CNQuestType(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*QuestTypeResponse).ToBNet(),nil
}*/


