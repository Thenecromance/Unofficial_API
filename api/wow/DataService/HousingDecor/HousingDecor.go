package wow_HousingDecor

// AUTOMATICALLY GENERATED FILE, DO NOT EDIT
// This file is generated by tools/updater
// Author: @Thenecromance

import (
	"context"
	"encoding/json"
	
	    "strconv"
	

	

	"io"
	"net/http"

	"Unofficial_API/ApiError"
	"Unofficial_API/api/Authentication"
	"Unofficial_API/global"
	"Unofficial_API/utils"


	"github.com/jtacoma/uritemplates"

)


// ==============================================================================================
// API: DecorIndex
// ==============================================================================================

type DecorIndexFields struct {
	Namespace string `form:"namespace,default=static-us"` // The namespace to use to locate this document.
	Locale string `form:"locale,default=en_US"` // The locale to reflect in localized data.

	// Extra fields for internal logic
	ExtraFields map[any]any
	CN          *utils.CNRequestMethod
	utils.RequestMethod
}

// CNHookDecorIndex allows injecting a custom implementation for the CN endpoint.
// Implement this in a separate file (e.g. init()) to handle CN logic without modifying generated code.
var CNHookDecorIndex func(context.Context, *DecorIndexFields) (any, error)

// StringDecorIndex executes the request and returns the raw response body string.
func StringDecorIndex(ctx context.Context, fields *DecorIndexFields) (string, error) {
	if fields == nil {
		fields = &DecorIndexFields{}
	}

	// 1. Initialize Request Metadata
	fields.RequestMethod = utils.GetApiConfig("DecorIndex")
	if fields.RequestMethod.Path == "" {
		fields.RequestMethod = utils.RequestMethod{
			Methods:  "GET",
			Path:     "/data/wow/decor/index",
			CnRegion: false,
		}
	}

	// 2. Apply Default Values (if needed for client-side logic)
	// Note: Usually struct tags handle server-side binding,
	// but here we might need manual checks if 0/"" are invalid for the request.
	
	if fields.Namespace == "" {
		fields.Namespace = "static-us"
	}
	
	
	if fields.Locale == "" {
		fields.Locale = "en_US"
	}
	
	

	// 3. Create HTTP Request
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		global.PortalURL, // Base URL will be joined with Path below
		nil,
	)
	if err != nil {
		return "", err
	}

	// Add Auth Header
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())

	// 4. Resolve Path (Handle URI Bindings)
	{
	
    	req.URL.Path = fields.Path
    	
	}

	// 5. Build Query Strings
{
	q := req.URL.Query()


	for key, value := range fields.ExtraFields {
		q.Add(key.(string), value.(string))
	}

	
    
	if !q.Has("namespace") {
		q.Add("namespace", "static-us")
	}
    
    
	if !q.Has("locale") {
		q.Add("locale", "en_US")
	}
    


	req.URL.RawQuery = q.Encode()
}

	// 6. Execute Request
	cli := http.Client{}
	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

// bridgeDecorIndex routes the request to either CN or Global logic based on input.
func bridgeDecorIndex(ctx context.Context, fields *DecorIndexFields) (any, error) {
    

	// 1. If CN specific parameters are present, use CN logic
	if fields.CN != nil {
        // Design Scheme: Check if a custom CN handler is registered at runtime.
		// This allows extension without modifying the template generator.
		if CNHookDecorIndex != nil {
			return CNHookDecorIndex(ctx, fields)
		}

		return nil, ApiError.ErrorNotSupported
	}

	// 2. Default: Use Global/Standard logic
	objString, err := StringDecorIndex(ctx, fields)
	if err != nil {
		return nil, err
	}

	resp := &DecorIndexModel{}
	if err = json.Unmarshal([]byte(objString), &resp); err != nil {
		return nil, err
	}

	return resp, nil
}

// DecorIndex
/* DecorIndex Returns an index of decor. */
// Path: /data/wow/decor/index
var DecorIndex = bridgeDecorIndex


// ==============================================================================================
// API: Decor
// ==============================================================================================

type DecorFields struct {
	DecorId string `uri:"decorId" binding:"required"` // The ID of the decor.
		Namespace string `form:"namespace,default=static-us"` // The namespace to use to locate this document.
	Locale string `form:"locale,default=en_US"` // The locale to reflect in localized data.

	// Extra fields for internal logic
	ExtraFields map[any]any
	CN          *utils.CNRequestMethod
	utils.RequestMethod
}

// CNHookDecor allows injecting a custom implementation for the CN endpoint.
// Implement this in a separate file (e.g. init()) to handle CN logic without modifying generated code.
var CNHookDecor func(context.Context, *DecorFields) (any, error)

// StringDecor executes the request and returns the raw response body string.
func StringDecor(ctx context.Context, fields *DecorFields) (string, error) {
	if fields == nil {
		fields = &DecorFields{}
	}

	// 1. Initialize Request Metadata
	fields.RequestMethod = utils.GetApiConfig("Decor")
	if fields.RequestMethod.Path == "" {
		fields.RequestMethod = utils.RequestMethod{
			Methods:  "GET",
			Path:     "/data/wow/decor/{decorId}",
			CnRegion: false,
		}
	}

	// 2. Apply Default Values (if needed for client-side logic)
	// Note: Usually struct tags handle server-side binding,
	// but here we might need manual checks if 0/"" are invalid for the request.
	
	if fields.DecorId == "" {
		fields.DecorId = "80"
	}
	
	
	if fields.Namespace == "" {
		fields.Namespace = "static-us"
	}
	
	
	if fields.Locale == "" {
		fields.Locale = "en_US"
	}
	
	

	// 3. Create HTTP Request
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		global.PortalURL, // Base URL will be joined with Path below
		nil,
	)
	if err != nil {
		return "", err
	}

	// Add Auth Header
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())

	// 4. Resolve Path (Handle URI Bindings)
	{
	
    	tpl, err := uritemplates.Parse(fields.Path)
    	if err != nil {
    		return "", err
    	}

    	pathValues := map[string]interface{}{
    		"decorId": fields.DecorId,
    		
    	}

    	expandedPath, err := tpl.Expand(pathValues)
    	if err != nil {
    		return "", err
    	}
    	req.URL.Path = expandedPath
    	
	}

	// 5. Build Query Strings
{
	q := req.URL.Query()


	for key, value := range fields.ExtraFields {
		q.Add(key.(string), value.(string))
	}

	
    
	if !q.Has("namespace") {
		q.Add("namespace", "static-us")
	}
    
    
	if !q.Has("locale") {
		q.Add("locale", "en_US")
	}
    


	req.URL.RawQuery = q.Encode()
}

	// 6. Execute Request
	cli := http.Client{}
	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

// bridgeDecor routes the request to either CN or Global logic based on input.
func bridgeDecor(ctx context.Context, fields *DecorFields) (any, error) {
    

	// 1. If CN specific parameters are present, use CN logic
	if fields.CN != nil {
        // Design Scheme: Check if a custom CN handler is registered at runtime.
		// This allows extension without modifying the template generator.
		if CNHookDecor != nil {
			return CNHookDecor(ctx, fields)
		}

		return nil, ApiError.ErrorNotSupported
	}

	// 2. Default: Use Global/Standard logic
	objString, err := StringDecor(ctx, fields)
	if err != nil {
		return nil, err
	}

	resp := &DecorModel{}
	if err = json.Unmarshal([]byte(objString), &resp); err != nil {
		return nil, err
	}

	return resp, nil
}

// Decor
/* Decor Returns a decor by ID. */
// Path: /data/wow/decor/{decorId}
var Decor = bridgeDecor


// ==============================================================================================
// API: DecorSearch
// ==============================================================================================

type DecorSearchFields struct {
	Namespace string `form:"namespace,default=static-us"` // The namespace to use to locate this document.
	Nameen_US string `form:"nameen_US,default=Fireplace"` // The name of the decor. (example search field)
	Orderby string `form:"orderby,default=id"` // The field to sort the result set by.
	_page int `form:"_page,default=1"` // The result page number.

	// Extra fields for internal logic
	ExtraFields map[any]any
	CN          *utils.CNRequestMethod
	utils.RequestMethod
}

// CNHookDecorSearch allows injecting a custom implementation for the CN endpoint.
// Implement this in a separate file (e.g. init()) to handle CN logic without modifying generated code.
var CNHookDecorSearch func(context.Context, *DecorSearchFields) (any, error)

// StringDecorSearch executes the request and returns the raw response body string.
func StringDecorSearch(ctx context.Context, fields *DecorSearchFields) (string, error) {
	if fields == nil {
		fields = &DecorSearchFields{}
	}

	// 1. Initialize Request Metadata
	fields.RequestMethod = utils.GetApiConfig("DecorSearch")
	if fields.RequestMethod.Path == "" {
		fields.RequestMethod = utils.RequestMethod{
			Methods:  "GET",
			Path:     "/data/wow/search/decor",
			CnRegion: false,
		}
	}

	// 2. Apply Default Values (if needed for client-side logic)
	// Note: Usually struct tags handle server-side binding,
	// but here we might need manual checks if 0/"" are invalid for the request.
	
	if fields.Namespace == "" {
		fields.Namespace = "static-us"
	}
	
	
	if fields.Nameen_US == "" {
		fields.Nameen_US = "Fireplace"
	}
	
	
	if fields.Orderby == "" {
		fields.Orderby = "id"
	}
	
	
	if fields._page == 0 {
		fields._page = 1
	}
	

	// 3. Create HTTP Request
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		global.PortalURL, // Base URL will be joined with Path below
		nil,
	)
	if err != nil {
		return "", err
	}

	// Add Auth Header
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())

	// 4. Resolve Path (Handle URI Bindings)
	{
	
    	req.URL.Path = fields.Path
    	
	}

	// 5. Build Query Strings
{
	q := req.URL.Query()


	for key, value := range fields.ExtraFields {
		q.Add(key.(string), value.(string))
	}

	
    
	if !q.Has("namespace") {
		q.Add("namespace", "static-us")
	}
    
    
	if !q.Has("nameen_US") {
		q.Add("nameen_US", "Fireplace")
	}
    
    
	if !q.Has("orderby") {
		q.Add("orderby", "id")
	}
    
    
    	if !q.Has("_page") {
    		q.Add("_page", strconv.Itoa(fields._page))
    	}
    


	req.URL.RawQuery = q.Encode()
}

	// 6. Execute Request
	cli := http.Client{}
	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

// bridgeDecorSearch routes the request to either CN or Global logic based on input.
func bridgeDecorSearch(ctx context.Context, fields *DecorSearchFields) (any, error) {
    

	// 1. If CN specific parameters are present, use CN logic
	if fields.CN != nil {
        // Design Scheme: Check if a custom CN handler is registered at runtime.
		// This allows extension without modifying the template generator.
		if CNHookDecorSearch != nil {
			return CNHookDecorSearch(ctx, fields)
		}

		return nil, ApiError.ErrorNotSupported
	}

	// 2. Default: Use Global/Standard logic
	objString, err := StringDecorSearch(ctx, fields)
	if err != nil {
		return nil, err
	}

	resp := &DecorSearchModel{}
	if err = json.Unmarshal([]byte(objString), &resp); err != nil {
		return nil, err
	}

	return resp, nil
}

// DecorSearch
/* DecorSearch Performs a search of decor. The fields below are provided for example. For more detail see the <a href="/documentation/world-of-warcraft/guides/search">Search Guide</a>. */
// Path: /data/wow/search/decor
var DecorSearch = bridgeDecorSearch


// ==============================================================================================
// API: FixtureIndex
// ==============================================================================================

type FixtureIndexFields struct {
	Namespace string `form:"namespace,default=static-us"` // The namespace to use to locate this document.
	Locale string `form:"locale,default=en_US"` // The locale to reflect in localized data.

	// Extra fields for internal logic
	ExtraFields map[any]any
	CN          *utils.CNRequestMethod
	utils.RequestMethod
}

// CNHookFixtureIndex allows injecting a custom implementation for the CN endpoint.
// Implement this in a separate file (e.g. init()) to handle CN logic without modifying generated code.
var CNHookFixtureIndex func(context.Context, *FixtureIndexFields) (any, error)

// StringFixtureIndex executes the request and returns the raw response body string.
func StringFixtureIndex(ctx context.Context, fields *FixtureIndexFields) (string, error) {
	if fields == nil {
		fields = &FixtureIndexFields{}
	}

	// 1. Initialize Request Metadata
	fields.RequestMethod = utils.GetApiConfig("FixtureIndex")
	if fields.RequestMethod.Path == "" {
		fields.RequestMethod = utils.RequestMethod{
			Methods:  "GET",
			Path:     "/data/wow/fixture/index",
			CnRegion: false,
		}
	}

	// 2. Apply Default Values (if needed for client-side logic)
	// Note: Usually struct tags handle server-side binding,
	// but here we might need manual checks if 0/"" are invalid for the request.
	
	if fields.Namespace == "" {
		fields.Namespace = "static-us"
	}
	
	
	if fields.Locale == "" {
		fields.Locale = "en_US"
	}
	
	

	// 3. Create HTTP Request
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		global.PortalURL, // Base URL will be joined with Path below
		nil,
	)
	if err != nil {
		return "", err
	}

	// Add Auth Header
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())

	// 4. Resolve Path (Handle URI Bindings)
	{
	
    	req.URL.Path = fields.Path
    	
	}

	// 5. Build Query Strings
{
	q := req.URL.Query()


	for key, value := range fields.ExtraFields {
		q.Add(key.(string), value.(string))
	}

	
    
	if !q.Has("namespace") {
		q.Add("namespace", "static-us")
	}
    
    
	if !q.Has("locale") {
		q.Add("locale", "en_US")
	}
    


	req.URL.RawQuery = q.Encode()
}

	// 6. Execute Request
	cli := http.Client{}
	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

// bridgeFixtureIndex routes the request to either CN or Global logic based on input.
func bridgeFixtureIndex(ctx context.Context, fields *FixtureIndexFields) (any, error) {
    

	// 1. If CN specific parameters are present, use CN logic
	if fields.CN != nil {
        // Design Scheme: Check if a custom CN handler is registered at runtime.
		// This allows extension without modifying the template generator.
		if CNHookFixtureIndex != nil {
			return CNHookFixtureIndex(ctx, fields)
		}

		return nil, ApiError.ErrorNotSupported
	}

	// 2. Default: Use Global/Standard logic
	objString, err := StringFixtureIndex(ctx, fields)
	if err != nil {
		return nil, err
	}

	resp := &FixtureIndexModel{}
	if err = json.Unmarshal([]byte(objString), &resp); err != nil {
		return nil, err
	}

	return resp, nil
}

// FixtureIndex
/* FixtureIndex Returns an index of fixtures. */
// Path: /data/wow/fixture/index
var FixtureIndex = bridgeFixtureIndex


// ==============================================================================================
// API: Fixture
// ==============================================================================================

type FixtureFields struct {
	DecorId string `uri:"decorId" binding:"required"` // The ID of the fixture.
		Namespace string `form:"namespace,default=static-us"` // The namespace to use to locate this document.
	Locale string `form:"locale,default=en_US"` // The locale to reflect in localized data.

	// Extra fields for internal logic
	ExtraFields map[any]any
	CN          *utils.CNRequestMethod
	utils.RequestMethod
}

// CNHookFixture allows injecting a custom implementation for the CN endpoint.
// Implement this in a separate file (e.g. init()) to handle CN logic without modifying generated code.
var CNHookFixture func(context.Context, *FixtureFields) (any, error)

// StringFixture executes the request and returns the raw response body string.
func StringFixture(ctx context.Context, fields *FixtureFields) (string, error) {
	if fields == nil {
		fields = &FixtureFields{}
	}

	// 1. Initialize Request Metadata
	fields.RequestMethod = utils.GetApiConfig("Fixture")
	if fields.RequestMethod.Path == "" {
		fields.RequestMethod = utils.RequestMethod{
			Methods:  "GET",
			Path:     "/data/wow/fixture/{fixtureId}",
			CnRegion: false,
		}
	}

	// 2. Apply Default Values (if needed for client-side logic)
	// Note: Usually struct tags handle server-side binding,
	// but here we might need manual checks if 0/"" are invalid for the request.
	
	if fields.DecorId == "" {
		fields.DecorId = "141"
	}
	
	
	if fields.Namespace == "" {
		fields.Namespace = "static-us"
	}
	
	
	if fields.Locale == "" {
		fields.Locale = "en_US"
	}
	
	

	// 3. Create HTTP Request
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		global.PortalURL, // Base URL will be joined with Path below
		nil,
	)
	if err != nil {
		return "", err
	}

	// Add Auth Header
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())

	// 4. Resolve Path (Handle URI Bindings)
	{
	
    	tpl, err := uritemplates.Parse(fields.Path)
    	if err != nil {
    		return "", err
    	}

    	pathValues := map[string]interface{}{
    		"decorId": fields.DecorId,
    		
    	}

    	expandedPath, err := tpl.Expand(pathValues)
    	if err != nil {
    		return "", err
    	}
    	req.URL.Path = expandedPath
    	
	}

	// 5. Build Query Strings
{
	q := req.URL.Query()


	for key, value := range fields.ExtraFields {
		q.Add(key.(string), value.(string))
	}

	
    
	if !q.Has("namespace") {
		q.Add("namespace", "static-us")
	}
    
    
	if !q.Has("locale") {
		q.Add("locale", "en_US")
	}
    


	req.URL.RawQuery = q.Encode()
}

	// 6. Execute Request
	cli := http.Client{}
	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

// bridgeFixture routes the request to either CN or Global logic based on input.
func bridgeFixture(ctx context.Context, fields *FixtureFields) (any, error) {
    

	// 1. If CN specific parameters are present, use CN logic
	if fields.CN != nil {
        // Design Scheme: Check if a custom CN handler is registered at runtime.
		// This allows extension without modifying the template generator.
		if CNHookFixture != nil {
			return CNHookFixture(ctx, fields)
		}

		return nil, ApiError.ErrorNotSupported
	}

	// 2. Default: Use Global/Standard logic
	objString, err := StringFixture(ctx, fields)
	if err != nil {
		return nil, err
	}

	resp := &FixtureModel{}
	if err = json.Unmarshal([]byte(objString), &resp); err != nil {
		return nil, err
	}

	return resp, nil
}

// Fixture
/* Fixture Returns a fixture by ID. */
// Path: /data/wow/fixture/{fixtureId}
var Fixture = bridgeFixture


// ==============================================================================================
// API: FixtureSearch
// ==============================================================================================

type FixtureSearchFields struct {
	Namespace string `form:"namespace,default=static-us"` // The namespace to use to locate this document.
	Nameen_US string `form:"nameen_US,default=Roof"` // The name of the decor. (example search field)
	Orderby string `form:"orderby,default=id"` // The field to sort the result set by.
	_page int `form:"_page,default=1"` // The result page number.

	// Extra fields for internal logic
	ExtraFields map[any]any
	CN          *utils.CNRequestMethod
	utils.RequestMethod
}

// CNHookFixtureSearch allows injecting a custom implementation for the CN endpoint.
// Implement this in a separate file (e.g. init()) to handle CN logic without modifying generated code.
var CNHookFixtureSearch func(context.Context, *FixtureSearchFields) (any, error)

// StringFixtureSearch executes the request and returns the raw response body string.
func StringFixtureSearch(ctx context.Context, fields *FixtureSearchFields) (string, error) {
	if fields == nil {
		fields = &FixtureSearchFields{}
	}

	// 1. Initialize Request Metadata
	fields.RequestMethod = utils.GetApiConfig("FixtureSearch")
	if fields.RequestMethod.Path == "" {
		fields.RequestMethod = utils.RequestMethod{
			Methods:  "GET",
			Path:     "/data/wow/search/fixture",
			CnRegion: false,
		}
	}

	// 2. Apply Default Values (if needed for client-side logic)
	// Note: Usually struct tags handle server-side binding,
	// but here we might need manual checks if 0/"" are invalid for the request.
	
	if fields.Namespace == "" {
		fields.Namespace = "static-us"
	}
	
	
	if fields.Nameen_US == "" {
		fields.Nameen_US = "Roof"
	}
	
	
	if fields.Orderby == "" {
		fields.Orderby = "id"
	}
	
	
	if fields._page == 0 {
		fields._page = 1
	}
	

	// 3. Create HTTP Request
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		global.PortalURL, // Base URL will be joined with Path below
		nil,
	)
	if err != nil {
		return "", err
	}

	// Add Auth Header
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())

	// 4. Resolve Path (Handle URI Bindings)
	{
	
    	req.URL.Path = fields.Path
    	
	}

	// 5. Build Query Strings
{
	q := req.URL.Query()


	for key, value := range fields.ExtraFields {
		q.Add(key.(string), value.(string))
	}

	
    
	if !q.Has("namespace") {
		q.Add("namespace", "static-us")
	}
    
    
	if !q.Has("nameen_US") {
		q.Add("nameen_US", "Roof")
	}
    
    
	if !q.Has("orderby") {
		q.Add("orderby", "id")
	}
    
    
    	if !q.Has("_page") {
    		q.Add("_page", strconv.Itoa(fields._page))
    	}
    


	req.URL.RawQuery = q.Encode()
}

	// 6. Execute Request
	cli := http.Client{}
	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

// bridgeFixtureSearch routes the request to either CN or Global logic based on input.
func bridgeFixtureSearch(ctx context.Context, fields *FixtureSearchFields) (any, error) {
    

	// 1. If CN specific parameters are present, use CN logic
	if fields.CN != nil {
        // Design Scheme: Check if a custom CN handler is registered at runtime.
		// This allows extension without modifying the template generator.
		if CNHookFixtureSearch != nil {
			return CNHookFixtureSearch(ctx, fields)
		}

		return nil, ApiError.ErrorNotSupported
	}

	// 2. Default: Use Global/Standard logic
	objString, err := StringFixtureSearch(ctx, fields)
	if err != nil {
		return nil, err
	}

	resp := &FixtureSearchModel{}
	if err = json.Unmarshal([]byte(objString), &resp); err != nil {
		return nil, err
	}

	return resp, nil
}

// FixtureSearch
/* FixtureSearch Performs a search of fixtures. The fields below are provided for example. For more detail see the <a href="/documentation/world-of-warcraft/guides/search">Search Guide</a>. */
// Path: /data/wow/search/fixture
var FixtureSearch = bridgeFixtureSearch


// ==============================================================================================
// API: FixtureHookIndex
// ==============================================================================================

type FixtureHookIndexFields struct {
	Namespace string `form:"namespace,default=static-us"` // The namespace to use to locate this document.
	Locale string `form:"locale,default=en_US"` // The locale to reflect in localized data.

	// Extra fields for internal logic
	ExtraFields map[any]any
	CN          *utils.CNRequestMethod
	utils.RequestMethod
}

// CNHookFixtureHookIndex allows injecting a custom implementation for the CN endpoint.
// Implement this in a separate file (e.g. init()) to handle CN logic without modifying generated code.
var CNHookFixtureHookIndex func(context.Context, *FixtureHookIndexFields) (any, error)

// StringFixtureHookIndex executes the request and returns the raw response body string.
func StringFixtureHookIndex(ctx context.Context, fields *FixtureHookIndexFields) (string, error) {
	if fields == nil {
		fields = &FixtureHookIndexFields{}
	}

	// 1. Initialize Request Metadata
	fields.RequestMethod = utils.GetApiConfig("FixtureHookIndex")
	if fields.RequestMethod.Path == "" {
		fields.RequestMethod = utils.RequestMethod{
			Methods:  "GET",
			Path:     "/data/wow/fixture-hook/index",
			CnRegion: false,
		}
	}

	// 2. Apply Default Values (if needed for client-side logic)
	// Note: Usually struct tags handle server-side binding,
	// but here we might need manual checks if 0/"" are invalid for the request.
	
	if fields.Namespace == "" {
		fields.Namespace = "static-us"
	}
	
	
	if fields.Locale == "" {
		fields.Locale = "en_US"
	}
	
	

	// 3. Create HTTP Request
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		global.PortalURL, // Base URL will be joined with Path below
		nil,
	)
	if err != nil {
		return "", err
	}

	// Add Auth Header
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())

	// 4. Resolve Path (Handle URI Bindings)
	{
	
    	req.URL.Path = fields.Path
    	
	}

	// 5. Build Query Strings
{
	q := req.URL.Query()


	for key, value := range fields.ExtraFields {
		q.Add(key.(string), value.(string))
	}

	
    
	if !q.Has("namespace") {
		q.Add("namespace", "static-us")
	}
    
    
	if !q.Has("locale") {
		q.Add("locale", "en_US")
	}
    


	req.URL.RawQuery = q.Encode()
}

	// 6. Execute Request
	cli := http.Client{}
	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

// bridgeFixtureHookIndex routes the request to either CN or Global logic based on input.
func bridgeFixtureHookIndex(ctx context.Context, fields *FixtureHookIndexFields) (any, error) {
    

	// 1. If CN specific parameters are present, use CN logic
	if fields.CN != nil {
        // Design Scheme: Check if a custom CN handler is registered at runtime.
		// This allows extension without modifying the template generator.
		if CNHookFixtureHookIndex != nil {
			return CNHookFixtureHookIndex(ctx, fields)
		}

		return nil, ApiError.ErrorNotSupported
	}

	// 2. Default: Use Global/Standard logic
	objString, err := StringFixtureHookIndex(ctx, fields)
	if err != nil {
		return nil, err
	}

	resp := &FixtureHookIndexModel{}
	if err = json.Unmarshal([]byte(objString), &resp); err != nil {
		return nil, err
	}

	return resp, nil
}

// FixtureHookIndex
/* FixtureHookIndex Returns an index of fixture hooks. */
// Path: /data/wow/fixture-hook/index
var FixtureHookIndex = bridgeFixtureHookIndex


// ==============================================================================================
// API: FixtureHook
// ==============================================================================================

type FixtureHookFields struct {
	FixtureHookId string `uri:"fixtureHookId" binding:"required"` // The ID of the fixture hook.
		Namespace string `form:"namespace,default=static-us"` // The namespace to use to locate this document.
	Locale string `form:"locale,default=en_US"` // The locale to reflect in localized data.

	// Extra fields for internal logic
	ExtraFields map[any]any
	CN          *utils.CNRequestMethod
	utils.RequestMethod
}

// CNHookFixtureHook allows injecting a custom implementation for the CN endpoint.
// Implement this in a separate file (e.g. init()) to handle CN logic without modifying generated code.
var CNHookFixtureHook func(context.Context, *FixtureHookFields) (any, error)

// StringFixtureHook executes the request and returns the raw response body string.
func StringFixtureHook(ctx context.Context, fields *FixtureHookFields) (string, error) {
	if fields == nil {
		fields = &FixtureHookFields{}
	}

	// 1. Initialize Request Metadata
	fields.RequestMethod = utils.GetApiConfig("FixtureHook")
	if fields.RequestMethod.Path == "" {
		fields.RequestMethod = utils.RequestMethod{
			Methods:  "GET",
			Path:     "/data/wow/fixture-hook/{fixtureHookId}",
			CnRegion: false,
		}
	}

	// 2. Apply Default Values (if needed for client-side logic)
	// Note: Usually struct tags handle server-side binding,
	// but here we might need manual checks if 0/"" are invalid for the request.
	
	if fields.FixtureHookId == "" {
		fields.FixtureHookId = "2503"
	}
	
	
	if fields.Namespace == "" {
		fields.Namespace = "static-us"
	}
	
	
	if fields.Locale == "" {
		fields.Locale = "en_US"
	}
	
	

	// 3. Create HTTP Request
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		global.PortalURL, // Base URL will be joined with Path below
		nil,
	)
	if err != nil {
		return "", err
	}

	// Add Auth Header
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())

	// 4. Resolve Path (Handle URI Bindings)
	{
	
    	tpl, err := uritemplates.Parse(fields.Path)
    	if err != nil {
    		return "", err
    	}

    	pathValues := map[string]interface{}{
    		"fixtureHookId": fields.FixtureHookId,
    		
    	}

    	expandedPath, err := tpl.Expand(pathValues)
    	if err != nil {
    		return "", err
    	}
    	req.URL.Path = expandedPath
    	
	}

	// 5. Build Query Strings
{
	q := req.URL.Query()


	for key, value := range fields.ExtraFields {
		q.Add(key.(string), value.(string))
	}

	
    
	if !q.Has("namespace") {
		q.Add("namespace", "static-us")
	}
    
    
	if !q.Has("locale") {
		q.Add("locale", "en_US")
	}
    


	req.URL.RawQuery = q.Encode()
}

	// 6. Execute Request
	cli := http.Client{}
	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

// bridgeFixtureHook routes the request to either CN or Global logic based on input.
func bridgeFixtureHook(ctx context.Context, fields *FixtureHookFields) (any, error) {
    

	// 1. If CN specific parameters are present, use CN logic
	if fields.CN != nil {
        // Design Scheme: Check if a custom CN handler is registered at runtime.
		// This allows extension without modifying the template generator.
		if CNHookFixtureHook != nil {
			return CNHookFixtureHook(ctx, fields)
		}

		return nil, ApiError.ErrorNotSupported
	}

	// 2. Default: Use Global/Standard logic
	objString, err := StringFixtureHook(ctx, fields)
	if err != nil {
		return nil, err
	}

	resp := &FixtureHookModel{}
	if err = json.Unmarshal([]byte(objString), &resp); err != nil {
		return nil, err
	}

	return resp, nil
}

// FixtureHook
/* FixtureHook Returns a fixture hook by ID. */
// Path: /data/wow/fixture-hook/{fixtureHookId}
var FixtureHook = bridgeFixtureHook


// ==============================================================================================
// API: FixtureHookSearch
// ==============================================================================================

type FixtureHookSearchFields struct {
	Namespace string `form:"namespace,default=static-us"` // The namespace to use to locate this document.
	Orderby string `form:"orderby,default=id"` // The field to sort the result set by.
	_page int `form:"_page,default=1"` // The result page number.

	// Extra fields for internal logic
	ExtraFields map[any]any
	CN          *utils.CNRequestMethod
	utils.RequestMethod
}

// CNHookFixtureHookSearch allows injecting a custom implementation for the CN endpoint.
// Implement this in a separate file (e.g. init()) to handle CN logic without modifying generated code.
var CNHookFixtureHookSearch func(context.Context, *FixtureHookSearchFields) (any, error)

// StringFixtureHookSearch executes the request and returns the raw response body string.
func StringFixtureHookSearch(ctx context.Context, fields *FixtureHookSearchFields) (string, error) {
	if fields == nil {
		fields = &FixtureHookSearchFields{}
	}

	// 1. Initialize Request Metadata
	fields.RequestMethod = utils.GetApiConfig("FixtureHookSearch")
	if fields.RequestMethod.Path == "" {
		fields.RequestMethod = utils.RequestMethod{
			Methods:  "GET",
			Path:     "/data/wow/search/fixture-hook",
			CnRegion: false,
		}
	}

	// 2. Apply Default Values (if needed for client-side logic)
	// Note: Usually struct tags handle server-side binding,
	// but here we might need manual checks if 0/"" are invalid for the request.
	
	if fields.Namespace == "" {
		fields.Namespace = "static-us"
	}
	
	
	if fields.Orderby == "" {
		fields.Orderby = "id"
	}
	
	
	if fields._page == 0 {
		fields._page = 1
	}
	

	// 3. Create HTTP Request
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		global.PortalURL, // Base URL will be joined with Path below
		nil,
	)
	if err != nil {
		return "", err
	}

	// Add Auth Header
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())

	// 4. Resolve Path (Handle URI Bindings)
	{
	
    	req.URL.Path = fields.Path
    	
	}

	// 5. Build Query Strings
{
	q := req.URL.Query()


	for key, value := range fields.ExtraFields {
		q.Add(key.(string), value.(string))
	}

	
    
	if !q.Has("namespace") {
		q.Add("namespace", "static-us")
	}
    
    
	if !q.Has("orderby") {
		q.Add("orderby", "id")
	}
    
    
    	if !q.Has("_page") {
    		q.Add("_page", strconv.Itoa(fields._page))
    	}
    


	req.URL.RawQuery = q.Encode()
}

	// 6. Execute Request
	cli := http.Client{}
	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

// bridgeFixtureHookSearch routes the request to either CN or Global logic based on input.
func bridgeFixtureHookSearch(ctx context.Context, fields *FixtureHookSearchFields) (any, error) {
    

	// 1. If CN specific parameters are present, use CN logic
	if fields.CN != nil {
        // Design Scheme: Check if a custom CN handler is registered at runtime.
		// This allows extension without modifying the template generator.
		if CNHookFixtureHookSearch != nil {
			return CNHookFixtureHookSearch(ctx, fields)
		}

		return nil, ApiError.ErrorNotSupported
	}

	// 2. Default: Use Global/Standard logic
	objString, err := StringFixtureHookSearch(ctx, fields)
	if err != nil {
		return nil, err
	}

	resp := &FixtureHookSearchModel{}
	if err = json.Unmarshal([]byte(objString), &resp); err != nil {
		return nil, err
	}

	return resp, nil
}

// FixtureHookSearch
/* FixtureHookSearch Performs a search of fixture hooks. The fields below are provided for example. For more detail see the <a href="/documentation/world-of-warcraft/guides/search">Search Guide</a>. */
// Path: /data/wow/search/fixture-hook
var FixtureHookSearch = bridgeFixtureHookSearch


// ==============================================================================================
// API: RoomIndex
// ==============================================================================================

type RoomIndexFields struct {
	Namespace string `form:"namespace,default=static-us"` // The namespace to use to locate this document.
	Locale string `form:"locale,default=en_US"` // The locale to reflect in localized data.

	// Extra fields for internal logic
	ExtraFields map[any]any
	CN          *utils.CNRequestMethod
	utils.RequestMethod
}

// CNHookRoomIndex allows injecting a custom implementation for the CN endpoint.
// Implement this in a separate file (e.g. init()) to handle CN logic without modifying generated code.
var CNHookRoomIndex func(context.Context, *RoomIndexFields) (any, error)

// StringRoomIndex executes the request and returns the raw response body string.
func StringRoomIndex(ctx context.Context, fields *RoomIndexFields) (string, error) {
	if fields == nil {
		fields = &RoomIndexFields{}
	}

	// 1. Initialize Request Metadata
	fields.RequestMethod = utils.GetApiConfig("RoomIndex")
	if fields.RequestMethod.Path == "" {
		fields.RequestMethod = utils.RequestMethod{
			Methods:  "GET",
			Path:     "/data/wow/room/index",
			CnRegion: false,
		}
	}

	// 2. Apply Default Values (if needed for client-side logic)
	// Note: Usually struct tags handle server-side binding,
	// but here we might need manual checks if 0/"" are invalid for the request.
	
	if fields.Namespace == "" {
		fields.Namespace = "static-us"
	}
	
	
	if fields.Locale == "" {
		fields.Locale = "en_US"
	}
	
	

	// 3. Create HTTP Request
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		global.PortalURL, // Base URL will be joined with Path below
		nil,
	)
	if err != nil {
		return "", err
	}

	// Add Auth Header
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())

	// 4. Resolve Path (Handle URI Bindings)
	{
	
    	req.URL.Path = fields.Path
    	
	}

	// 5. Build Query Strings
{
	q := req.URL.Query()


	for key, value := range fields.ExtraFields {
		q.Add(key.(string), value.(string))
	}

	
    
	if !q.Has("namespace") {
		q.Add("namespace", "static-us")
	}
    
    
	if !q.Has("locale") {
		q.Add("locale", "en_US")
	}
    


	req.URL.RawQuery = q.Encode()
}

	// 6. Execute Request
	cli := http.Client{}
	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

// bridgeRoomIndex routes the request to either CN or Global logic based on input.
func bridgeRoomIndex(ctx context.Context, fields *RoomIndexFields) (any, error) {
    

	// 1. If CN specific parameters are present, use CN logic
	if fields.CN != nil {
        // Design Scheme: Check if a custom CN handler is registered at runtime.
		// This allows extension without modifying the template generator.
		if CNHookRoomIndex != nil {
			return CNHookRoomIndex(ctx, fields)
		}

		return nil, ApiError.ErrorNotSupported
	}

	// 2. Default: Use Global/Standard logic
	objString, err := StringRoomIndex(ctx, fields)
	if err != nil {
		return nil, err
	}

	resp := &RoomIndexModel{}
	if err = json.Unmarshal([]byte(objString), &resp); err != nil {
		return nil, err
	}

	return resp, nil
}

// RoomIndex
/* RoomIndex Returns an index of rooms. */
// Path: /data/wow/room/index
var RoomIndex = bridgeRoomIndex


// ==============================================================================================
// API: Room
// ==============================================================================================

type RoomFields struct {
	RoomId string `uri:"roomId" binding:"required"` // The ID of the room.
		Namespace string `form:"namespace,default=static-us"` // The namespace to use to locate this document.
	Locale string `form:"locale,default=en_US"` // The locale to reflect in localized data.

	// Extra fields for internal logic
	ExtraFields map[any]any
	CN          *utils.CNRequestMethod
	utils.RequestMethod
}

// CNHookRoom allows injecting a custom implementation for the CN endpoint.
// Implement this in a separate file (e.g. init()) to handle CN logic without modifying generated code.
var CNHookRoom func(context.Context, *RoomFields) (any, error)

// StringRoom executes the request and returns the raw response body string.
func StringRoom(ctx context.Context, fields *RoomFields) (string, error) {
	if fields == nil {
		fields = &RoomFields{}
	}

	// 1. Initialize Request Metadata
	fields.RequestMethod = utils.GetApiConfig("Room")
	if fields.RequestMethod.Path == "" {
		fields.RequestMethod = utils.RequestMethod{
			Methods:  "GET",
			Path:     "/data/wow/room/{roomId}",
			CnRegion: false,
		}
	}

	// 2. Apply Default Values (if needed for client-side logic)
	// Note: Usually struct tags handle server-side binding,
	// but here we might need manual checks if 0/"" are invalid for the request.
	
	if fields.RoomId == "" {
		fields.RoomId = "1"
	}
	
	
	if fields.Namespace == "" {
		fields.Namespace = "static-us"
	}
	
	
	if fields.Locale == "" {
		fields.Locale = "en_US"
	}
	
	

	// 3. Create HTTP Request
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		global.PortalURL, // Base URL will be joined with Path below
		nil,
	)
	if err != nil {
		return "", err
	}

	// Add Auth Header
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())

	// 4. Resolve Path (Handle URI Bindings)
	{
	
    	tpl, err := uritemplates.Parse(fields.Path)
    	if err != nil {
    		return "", err
    	}

    	pathValues := map[string]interface{}{
    		"roomId": fields.RoomId,
    		
    	}

    	expandedPath, err := tpl.Expand(pathValues)
    	if err != nil {
    		return "", err
    	}
    	req.URL.Path = expandedPath
    	
	}

	// 5. Build Query Strings
{
	q := req.URL.Query()


	for key, value := range fields.ExtraFields {
		q.Add(key.(string), value.(string))
	}

	
    
	if !q.Has("namespace") {
		q.Add("namespace", "static-us")
	}
    
    
	if !q.Has("locale") {
		q.Add("locale", "en_US")
	}
    


	req.URL.RawQuery = q.Encode()
}

	// 6. Execute Request
	cli := http.Client{}
	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

// bridgeRoom routes the request to either CN or Global logic based on input.
func bridgeRoom(ctx context.Context, fields *RoomFields) (any, error) {
    

	// 1. If CN specific parameters are present, use CN logic
	if fields.CN != nil {
        // Design Scheme: Check if a custom CN handler is registered at runtime.
		// This allows extension without modifying the template generator.
		if CNHookRoom != nil {
			return CNHookRoom(ctx, fields)
		}

		return nil, ApiError.ErrorNotSupported
	}

	// 2. Default: Use Global/Standard logic
	objString, err := StringRoom(ctx, fields)
	if err != nil {
		return nil, err
	}

	resp := &RoomModel{}
	if err = json.Unmarshal([]byte(objString), &resp); err != nil {
		return nil, err
	}

	return resp, nil
}

// Room
/* Room Returns a room by ID. */
// Path: /data/wow/room/{roomId}
var Room = bridgeRoom


// ==============================================================================================
// API: RoomSearch
// ==============================================================================================

type RoomSearchFields struct {
	Namespace string `form:"namespace,default=static-us"` // The namespace to use to locate this document.
	Nameen_US string `form:"nameen_US,default=Square"` // The name of the room. (example search field)
	Orderby string `form:"orderby,default=id"` // The field to sort the result set by.
	_page int `form:"_page,default=1"` // The result page number.

	// Extra fields for internal logic
	ExtraFields map[any]any
	CN          *utils.CNRequestMethod
	utils.RequestMethod
}

// CNHookRoomSearch allows injecting a custom implementation for the CN endpoint.
// Implement this in a separate file (e.g. init()) to handle CN logic without modifying generated code.
var CNHookRoomSearch func(context.Context, *RoomSearchFields) (any, error)

// StringRoomSearch executes the request and returns the raw response body string.
func StringRoomSearch(ctx context.Context, fields *RoomSearchFields) (string, error) {
	if fields == nil {
		fields = &RoomSearchFields{}
	}

	// 1. Initialize Request Metadata
	fields.RequestMethod = utils.GetApiConfig("RoomSearch")
	if fields.RequestMethod.Path == "" {
		fields.RequestMethod = utils.RequestMethod{
			Methods:  "GET",
			Path:     "/data/wow/search/room",
			CnRegion: false,
		}
	}

	// 2. Apply Default Values (if needed for client-side logic)
	// Note: Usually struct tags handle server-side binding,
	// but here we might need manual checks if 0/"" are invalid for the request.
	
	if fields.Namespace == "" {
		fields.Namespace = "static-us"
	}
	
	
	if fields.Nameen_US == "" {
		fields.Nameen_US = "Square"
	}
	
	
	if fields.Orderby == "" {
		fields.Orderby = "id"
	}
	
	
	if fields._page == 0 {
		fields._page = 1
	}
	

	// 3. Create HTTP Request
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		global.PortalURL, // Base URL will be joined with Path below
		nil,
	)
	if err != nil {
		return "", err
	}

	// Add Auth Header
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())

	// 4. Resolve Path (Handle URI Bindings)
	{
	
    	req.URL.Path = fields.Path
    	
	}

	// 5. Build Query Strings
{
	q := req.URL.Query()


	for key, value := range fields.ExtraFields {
		q.Add(key.(string), value.(string))
	}

	
    
	if !q.Has("namespace") {
		q.Add("namespace", "static-us")
	}
    
    
	if !q.Has("nameen_US") {
		q.Add("nameen_US", "Square")
	}
    
    
	if !q.Has("orderby") {
		q.Add("orderby", "id")
	}
    
    
    	if !q.Has("_page") {
    		q.Add("_page", strconv.Itoa(fields._page))
    	}
    


	req.URL.RawQuery = q.Encode()
}

	// 6. Execute Request
	cli := http.Client{}
	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

// bridgeRoomSearch routes the request to either CN or Global logic based on input.
func bridgeRoomSearch(ctx context.Context, fields *RoomSearchFields) (any, error) {
    

	// 1. If CN specific parameters are present, use CN logic
	if fields.CN != nil {
        // Design Scheme: Check if a custom CN handler is registered at runtime.
		// This allows extension without modifying the template generator.
		if CNHookRoomSearch != nil {
			return CNHookRoomSearch(ctx, fields)
		}

		return nil, ApiError.ErrorNotSupported
	}

	// 2. Default: Use Global/Standard logic
	objString, err := StringRoomSearch(ctx, fields)
	if err != nil {
		return nil, err
	}

	resp := &RoomSearchModel{}
	if err = json.Unmarshal([]byte(objString), &resp); err != nil {
		return nil, err
	}

	return resp, nil
}

// RoomSearch
/* RoomSearch Performs a search of rooms. The fields below are provided for example. For more detail see the <a href="/documentation/world-of-warcraft/guides/search">Search Guide</a>. */
// Path: /data/wow/search/room
var RoomSearch = bridgeRoomSearch

