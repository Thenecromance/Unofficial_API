package wowRetail_HousingDecor
// AUTOMATICALLY GENERATED FILE, DO NOT EDIT
// This file is generated by tools/updater
// Author: @Thenecromance 
import (
	"Unofficial_API/api/Authentication"
	"Unofficial_API/utils"
	"context"
	"encoding/json"
	"io"
	"net/http"
	"strconv"
)

 
//==============================================================================================

type DecorIndexFields struct{
	Namespace string//The namespace to use to locate this document.
	Locale string//The locale to reflect in localized data.
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func DecorIndexField(input *DecorIndexFields) *DecorIndexFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/data/wow/decor/index",
//			CnRegion:false ,
//}
//return input
//}


//DecorIndex Returns an index of decor.
//
//@see: /data/wow/decor/index
func StringDecorIndex(ctx context.Context, fields *DecorIndexFields)(string,error){
	if fields == nil {
		fields = &DecorIndexFields{}
	}

	func(input *DecorIndexFields) {
	
if input.Namespace==""{
input.Namespace = "static-us"
}

	
if input.Locale==""{
input.Locale = "en_US"
}

	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/data/wow/decor/index",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("namespace", fields.Namespace)
	q.Add("locale", fields.Locale)
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNDecorIndex(ctx context.Context, fields *DecorIndexFields)(any,error){

obj, err := StringDecorIndex(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&DecorIndexResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var DecorIndex = CNDecorIndex
/*func BNetDecorIndex(ctx context.Context, fields *DecorIndexFields)(any,error){

obj ,err := CNDecorIndex(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*DecorIndexResponse).ToBNet(),nil
}*/

 
//==============================================================================================

type DecorFields struct{
	DecorId string//The ID of the decor.
	Namespace string//The namespace to use to locate this document.
	Locale string//The locale to reflect in localized data.
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func DecorField(input *DecorFields) *DecorFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/data/wow/decor/{decorId}",
//			CnRegion:false ,
//}
//return input
//}


//Decor Returns a decor by ID.
//
//@see: /data/wow/decor/{decorId}
func StringDecor(ctx context.Context, fields *DecorFields)(string,error){
	if fields == nil {
		fields = &DecorFields{}
	}

	func(input *DecorFields) {
	
if input.DecorId==""{
input.DecorId = "80"
}

	
if input.Namespace==""{
input.Namespace = "static-us"
}

	
if input.Locale==""{
input.Locale = "en_US"
}

	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/data/wow/decor/{decorId}",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("decorId", fields.DecorId)
	q.Add("namespace", fields.Namespace)
	q.Add("locale", fields.Locale)
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNDecor(ctx context.Context, fields *DecorFields)(any,error){

obj, err := StringDecor(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&DecorResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var Decor = CNDecor
/*func BNetDecor(ctx context.Context, fields *DecorFields)(any,error){

obj ,err := CNDecor(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*DecorResponse).ToBNet(),nil
}*/

 
//==============================================================================================

type DecorSearchFields struct{
	Namespace string//The namespace to use to locate this document.
	NameDoten_US string//The name of the decor. (example search field)
	Orderby string//The field to sort the result set by.
	_page int//The result page number.
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func DecorSearchField(input *DecorSearchFields) *DecorSearchFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/data/wow/search/decor",
//			CnRegion:false ,
//}
//return input
//}


//DecorSearch Performs a search of decor. The fields below are provided for example. For more detail see the <a href="/documentation/world-of-warcraft/guides/search">Search Guide</a>.
//
//@see: /data/wow/search/decor
func StringDecorSearch(ctx context.Context, fields *DecorSearchFields)(string,error){
	if fields == nil {
		fields = &DecorSearchFields{}
	}

	func(input *DecorSearchFields) {
	
if input.Namespace==""{
input.Namespace = "static-us"
}

	
if input.NameDoten_US==""{
input.NameDoten_US = "Fireplace"
}

	
if input.Orderby==""{
input.Orderby = "id"
}

	
if input._page==0{
input._page = 1
}
	
	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/data/wow/search/decor",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("namespace", fields.Namespace)
	q.Add("nameDoten_US", fields.NameDoten_US)
	q.Add("orderby", fields.Orderby)
	q.Add("_page", strconv.Itoa(fields._page))
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNDecorSearch(ctx context.Context, fields *DecorSearchFields)(any,error){

obj, err := StringDecorSearch(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&DecorSearchResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var DecorSearch = CNDecorSearch
/*func BNetDecorSearch(ctx context.Context, fields *DecorSearchFields)(any,error){

obj ,err := CNDecorSearch(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*DecorSearchResponse).ToBNet(),nil
}*/

 
//==============================================================================================

type FixtureIndexFields struct{
	Namespace string//The namespace to use to locate this document.
	Locale string//The locale to reflect in localized data.
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func FixtureIndexField(input *FixtureIndexFields) *FixtureIndexFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/data/wow/fixture/index",
//			CnRegion:false ,
//}
//return input
//}


//FixtureIndex Returns an index of fixtures.
//
//@see: /data/wow/fixture/index
func StringFixtureIndex(ctx context.Context, fields *FixtureIndexFields)(string,error){
	if fields == nil {
		fields = &FixtureIndexFields{}
	}

	func(input *FixtureIndexFields) {
	
if input.Namespace==""{
input.Namespace = "static-us"
}

	
if input.Locale==""{
input.Locale = "en_US"
}

	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/data/wow/fixture/index",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("namespace", fields.Namespace)
	q.Add("locale", fields.Locale)
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNFixtureIndex(ctx context.Context, fields *FixtureIndexFields)(any,error){

obj, err := StringFixtureIndex(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&FixtureIndexResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var FixtureIndex = CNFixtureIndex
/*func BNetFixtureIndex(ctx context.Context, fields *FixtureIndexFields)(any,error){

obj ,err := CNFixtureIndex(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*FixtureIndexResponse).ToBNet(),nil
}*/

 
//==============================================================================================

type FixtureFields struct{
	DecorId string//The ID of the fixture.
	Namespace string//The namespace to use to locate this document.
	Locale string//The locale to reflect in localized data.
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func FixtureField(input *FixtureFields) *FixtureFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/data/wow/fixture/{fixtureId}",
//			CnRegion:false ,
//}
//return input
//}


//Fixture Returns a fixture by ID.
//
//@see: /data/wow/fixture/{fixtureId}
func StringFixture(ctx context.Context, fields *FixtureFields)(string,error){
	if fields == nil {
		fields = &FixtureFields{}
	}

	func(input *FixtureFields) {
	
if input.DecorId==""{
input.DecorId = "141"
}

	
if input.Namespace==""{
input.Namespace = "static-us"
}

	
if input.Locale==""{
input.Locale = "en_US"
}

	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/data/wow/fixture/{fixtureId}",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("decorId", fields.DecorId)
	q.Add("namespace", fields.Namespace)
	q.Add("locale", fields.Locale)
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNFixture(ctx context.Context, fields *FixtureFields)(any,error){

obj, err := StringFixture(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&FixtureResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var Fixture = CNFixture
/*func BNetFixture(ctx context.Context, fields *FixtureFields)(any,error){

obj ,err := CNFixture(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*FixtureResponse).ToBNet(),nil
}*/

 
//==============================================================================================

type FixtureSearchFields struct{
	Namespace string//The namespace to use to locate this document.
	NameDoten_US string//The name of the decor. (example search field)
	Orderby string//The field to sort the result set by.
	_page int//The result page number.
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func FixtureSearchField(input *FixtureSearchFields) *FixtureSearchFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/data/wow/search/fixture",
//			CnRegion:false ,
//}
//return input
//}


//FixtureSearch Performs a search of fixtures. The fields below are provided for example. For more detail see the <a href="/documentation/world-of-warcraft/guides/search">Search Guide</a>.
//
//@see: /data/wow/search/fixture
func StringFixtureSearch(ctx context.Context, fields *FixtureSearchFields)(string,error){
	if fields == nil {
		fields = &FixtureSearchFields{}
	}

	func(input *FixtureSearchFields) {
	
if input.Namespace==""{
input.Namespace = "static-us"
}

	
if input.NameDoten_US==""{
input.NameDoten_US = "Roof"
}

	
if input.Orderby==""{
input.Orderby = "id"
}

	
if input._page==0{
input._page = 1
}
	
	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/data/wow/search/fixture",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("namespace", fields.Namespace)
	q.Add("nameDoten_US", fields.NameDoten_US)
	q.Add("orderby", fields.Orderby)
	q.Add("_page", strconv.Itoa(fields._page))
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNFixtureSearch(ctx context.Context, fields *FixtureSearchFields)(any,error){

obj, err := StringFixtureSearch(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&FixtureSearchResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var FixtureSearch = CNFixtureSearch
/*func BNetFixtureSearch(ctx context.Context, fields *FixtureSearchFields)(any,error){

obj ,err := CNFixtureSearch(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*FixtureSearchResponse).ToBNet(),nil
}*/

 
//==============================================================================================

type FixtureHookIndexFields struct{
	Namespace string//The namespace to use to locate this document.
	Locale string//The locale to reflect in localized data.
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func FixtureHookIndexField(input *FixtureHookIndexFields) *FixtureHookIndexFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/data/wow/fixture-hook/index",
//			CnRegion:false ,
//}
//return input
//}


//FixtureHookIndex Returns an index of fixture hooks.
//
//@see: /data/wow/fixture-hook/index
func StringFixtureHookIndex(ctx context.Context, fields *FixtureHookIndexFields)(string,error){
	if fields == nil {
		fields = &FixtureHookIndexFields{}
	}

	func(input *FixtureHookIndexFields) {
	
if input.Namespace==""{
input.Namespace = "static-us"
}

	
if input.Locale==""{
input.Locale = "en_US"
}

	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/data/wow/fixture-hook/index",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("namespace", fields.Namespace)
	q.Add("locale", fields.Locale)
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNFixtureHookIndex(ctx context.Context, fields *FixtureHookIndexFields)(any,error){

obj, err := StringFixtureHookIndex(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&FixtureHookIndexResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var FixtureHookIndex = CNFixtureHookIndex
/*func BNetFixtureHookIndex(ctx context.Context, fields *FixtureHookIndexFields)(any,error){

obj ,err := CNFixtureHookIndex(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*FixtureHookIndexResponse).ToBNet(),nil
}*/

 
//==============================================================================================

type FixtureHookFields struct{
	FixtureHookId string//The ID of the fixture hook.
	Namespace string//The namespace to use to locate this document.
	Locale string//The locale to reflect in localized data.
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func FixtureHookField(input *FixtureHookFields) *FixtureHookFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/data/wow/fixture-hook/{fixtureHookId}",
//			CnRegion:false ,
//}
//return input
//}


//FixtureHook Returns a fixture hook by ID.
//
//@see: /data/wow/fixture-hook/{fixtureHookId}
func StringFixtureHook(ctx context.Context, fields *FixtureHookFields)(string,error){
	if fields == nil {
		fields = &FixtureHookFields{}
	}

	func(input *FixtureHookFields) {
	
if input.FixtureHookId==""{
input.FixtureHookId = "2503"
}

	
if input.Namespace==""{
input.Namespace = "static-us"
}

	
if input.Locale==""{
input.Locale = "en_US"
}

	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/data/wow/fixture-hook/{fixtureHookId}",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("fixtureHookId", fields.FixtureHookId)
	q.Add("namespace", fields.Namespace)
	q.Add("locale", fields.Locale)
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNFixtureHook(ctx context.Context, fields *FixtureHookFields)(any,error){

obj, err := StringFixtureHook(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&FixtureHookResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var FixtureHook = CNFixtureHook
/*func BNetFixtureHook(ctx context.Context, fields *FixtureHookFields)(any,error){

obj ,err := CNFixtureHook(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*FixtureHookResponse).ToBNet(),nil
}*/

 
//==============================================================================================

type FixtureHookSearchFields struct{
	Namespace string//The namespace to use to locate this document.
	Orderby string//The field to sort the result set by.
	_page int//The result page number.
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func FixtureHookSearchField(input *FixtureHookSearchFields) *FixtureHookSearchFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/data/wow/search/fixture-hook",
//			CnRegion:false ,
//}
//return input
//}


//FixtureHookSearch Performs a search of fixture hooks. The fields below are provided for example. For more detail see the <a href="/documentation/world-of-warcraft/guides/search">Search Guide</a>.
//
//@see: /data/wow/search/fixture-hook
func StringFixtureHookSearch(ctx context.Context, fields *FixtureHookSearchFields)(string,error){
	if fields == nil {
		fields = &FixtureHookSearchFields{}
	}

	func(input *FixtureHookSearchFields) {
	
if input.Namespace==""{
input.Namespace = "static-us"
}

	
if input.Orderby==""{
input.Orderby = "id"
}

	
if input._page==0{
input._page = 1
}
	
	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/data/wow/search/fixture-hook",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("namespace", fields.Namespace)
	q.Add("orderby", fields.Orderby)
	q.Add("_page", strconv.Itoa(fields._page))
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNFixtureHookSearch(ctx context.Context, fields *FixtureHookSearchFields)(any,error){

obj, err := StringFixtureHookSearch(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&FixtureHookSearchResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var FixtureHookSearch = CNFixtureHookSearch
/*func BNetFixtureHookSearch(ctx context.Context, fields *FixtureHookSearchFields)(any,error){

obj ,err := CNFixtureHookSearch(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*FixtureHookSearchResponse).ToBNet(),nil
}*/

 
//==============================================================================================

type RoomIndexFields struct{
	Namespace string//The namespace to use to locate this document.
	Locale string//The locale to reflect in localized data.
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func RoomIndexField(input *RoomIndexFields) *RoomIndexFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/data/wow/room/index",
//			CnRegion:false ,
//}
//return input
//}


//RoomIndex Returns an index of rooms.
//
//@see: /data/wow/room/index
func StringRoomIndex(ctx context.Context, fields *RoomIndexFields)(string,error){
	if fields == nil {
		fields = &RoomIndexFields{}
	}

	func(input *RoomIndexFields) {
	
if input.Namespace==""{
input.Namespace = "static-us"
}

	
if input.Locale==""{
input.Locale = "en_US"
}

	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/data/wow/room/index",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("namespace", fields.Namespace)
	q.Add("locale", fields.Locale)
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNRoomIndex(ctx context.Context, fields *RoomIndexFields)(any,error){

obj, err := StringRoomIndex(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&RoomIndexResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var RoomIndex = CNRoomIndex
/*func BNetRoomIndex(ctx context.Context, fields *RoomIndexFields)(any,error){

obj ,err := CNRoomIndex(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*RoomIndexResponse).ToBNet(),nil
}*/

 
//==============================================================================================

type RoomFields struct{
	RoomId string//The ID of the room.
	Namespace string//The namespace to use to locate this document.
	Locale string//The locale to reflect in localized data.
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func RoomField(input *RoomFields) *RoomFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/data/wow/room/{roomId}",
//			CnRegion:false ,
//}
//return input
//}


//Room Returns a room by ID.
//
//@see: /data/wow/room/{roomId}
func StringRoom(ctx context.Context, fields *RoomFields)(string,error){
	if fields == nil {
		fields = &RoomFields{}
	}

	func(input *RoomFields) {
	
if input.RoomId==""{
input.RoomId = "1"
}

	
if input.Namespace==""{
input.Namespace = "static-us"
}

	
if input.Locale==""{
input.Locale = "en_US"
}

	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/data/wow/room/{roomId}",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("roomId", fields.RoomId)
	q.Add("namespace", fields.Namespace)
	q.Add("locale", fields.Locale)
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNRoom(ctx context.Context, fields *RoomFields)(any,error){

obj, err := StringRoom(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&RoomResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var Room = CNRoom
/*func BNetRoom(ctx context.Context, fields *RoomFields)(any,error){

obj ,err := CNRoom(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*RoomResponse).ToBNet(),nil
}*/

 
//==============================================================================================

type RoomSearchFields struct{
	Namespace string//The namespace to use to locate this document.
	NameDoten_US string//The name of the room. (example search field)
	Orderby string//The field to sort the result set by.
	_page int//The result page number.
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func RoomSearchField(input *RoomSearchFields) *RoomSearchFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/data/wow/search/room",
//			CnRegion:false ,
//}
//return input
//}


//RoomSearch Performs a search of rooms. The fields below are provided for example. For more detail see the <a href="/documentation/world-of-warcraft/guides/search">Search Guide</a>.
//
//@see: /data/wow/search/room
func StringRoomSearch(ctx context.Context, fields *RoomSearchFields)(string,error){
	if fields == nil {
		fields = &RoomSearchFields{}
	}

	func(input *RoomSearchFields) {
	
if input.Namespace==""{
input.Namespace = "static-us"
}

	
if input.NameDoten_US==""{
input.NameDoten_US = "Square"
}

	
if input.Orderby==""{
input.Orderby = "id"
}

	
if input._page==0{
input._page = 1
}
	
	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/data/wow/search/room",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("namespace", fields.Namespace)
	q.Add("nameDoten_US", fields.NameDoten_US)
	q.Add("orderby", fields.Orderby)
	q.Add("_page", strconv.Itoa(fields._page))
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNRoomSearch(ctx context.Context, fields *RoomSearchFields)(any,error){

obj, err := StringRoomSearch(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&RoomSearchResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var RoomSearch = CNRoomSearch
/*func BNetRoomSearch(ctx context.Context, fields *RoomSearchFields)(any,error){

obj ,err := CNRoomSearch(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*RoomSearchResponse).ToBNet(),nil
}*/


