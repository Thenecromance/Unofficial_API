package wowRetail_Talent
// AUTOMATICALLY GENERATED FILE, DO NOT EDIT
// This file is generated by tools/updater
// Author: @Thenecromance 
import (
	"Unofficial_API/api/Authentication"
	"Unofficial_API/utils"
	"context"
	"encoding/json"
	"io"
	"net/http"
	"strconv"
)

 
//==============================================================================================

type TalentTreeIndexFields struct{
	Namespace string//The namespace to use to locate this document.
	Locale string//The locale to reflect in localized data.
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func TalentTreeIndexField(input *TalentTreeIndexFields) *TalentTreeIndexFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/data/wow/talent-tree/index",
//			CnRegion:false ,
//}
//return input
//}


//TalentTreeIndex Returns an index of talent trees.
//
//@see: /data/wow/talent-tree/index
func StringTalentTreeIndex(ctx context.Context, fields *TalentTreeIndexFields)(string,error){
	if fields == nil {
		fields = &TalentTreeIndexFields{}
	}

	func(input *TalentTreeIndexFields) {
	
if input.Namespace==""{
input.Namespace = "static-us"
}

	
if input.Locale==""{
input.Locale = "en_US"
}

	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/data/wow/talent-tree/index",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("namespace", fields.Namespace)
	q.Add("locale", fields.Locale)
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNTalentTreeIndex(ctx context.Context, fields *TalentTreeIndexFields)(any,error){

obj, err := StringTalentTreeIndex(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&TalentTreeIndexResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var TalentTreeIndex = CNTalentTreeIndex
/*func BNetTalentTreeIndex(ctx context.Context, fields *TalentTreeIndexFields)(any,error){

obj ,err := CNTalentTreeIndex(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*TalentTreeIndexResponse).ToBNet(),nil
}*/

 
//==============================================================================================

type TalentTreeFields struct{
	TalentTreeId int//The ID of the talent-tree.
	SpecId int//The ID of the playable-specialization.
	Namespace string//The namespace to use to locate this document.
	Locale string//The locale to reflect in localized data.
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func TalentTreeField(input *TalentTreeFields) *TalentTreeFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/data/wow/talent-tree/{talentTreeId}/playable-specialization/{specId}",
//			CnRegion:false ,
//}
//return input
//}


//TalentTree Returns a talent tree by specialization ID.
//
//@see: /data/wow/talent-tree/{talentTreeId}/playable-specialization/{specId}
func StringTalentTree(ctx context.Context, fields *TalentTreeFields)(string,error){
	if fields == nil {
		fields = &TalentTreeFields{}
	}

	func(input *TalentTreeFields) {
	
if input.TalentTreeId==0{
input.TalentTreeId = 786
}
	
	
if input.SpecId==0{
input.SpecId = 262
}
	
	
if input.Namespace==""{
input.Namespace = "static-us"
}

	
if input.Locale==""{
input.Locale = "en_US"
}

	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/data/wow/talent-tree/{talentTreeId}/playable-specialization/{specId}",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("talentTreeId", strconv.Itoa(fields.TalentTreeId))
	q.Add("specId", strconv.Itoa(fields.SpecId))
	q.Add("namespace", fields.Namespace)
	q.Add("locale", fields.Locale)
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNTalentTree(ctx context.Context, fields *TalentTreeFields)(any,error){

obj, err := StringTalentTree(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&TalentTreeResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var TalentTree = CNTalentTree
/*func BNetTalentTree(ctx context.Context, fields *TalentTreeFields)(any,error){

obj ,err := CNTalentTree(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*TalentTreeResponse).ToBNet(),nil
}*/

 
//==============================================================================================

type TalentTreeNodesFields struct{
	TalentTreeId int//The ID of the talent-tree.
	Namespace string//The namespace to use to locate this document.
	Locale string//The locale to reflect in localized data.
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func TalentTreeNodesField(input *TalentTreeNodesFields) *TalentTreeNodesFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/data/wow/talent-tree/{talentTreeId}",
//			CnRegion:false ,
//}
//return input
//}


//TalentTreeNodes Returns all talent tree nodes as well as links to associated playable specializations given a talent tree id. This is useful to generate loadout export codes.
//
//@see: /data/wow/talent-tree/{talentTreeId}
func StringTalentTreeNodes(ctx context.Context, fields *TalentTreeNodesFields)(string,error){
	if fields == nil {
		fields = &TalentTreeNodesFields{}
	}

	func(input *TalentTreeNodesFields) {
	
if input.TalentTreeId==0{
input.TalentTreeId = 786
}
	
	
if input.Namespace==""{
input.Namespace = "static-us"
}

	
if input.Locale==""{
input.Locale = "en_US"
}

	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/data/wow/talent-tree/{talentTreeId}",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("talentTreeId", strconv.Itoa(fields.TalentTreeId))
	q.Add("namespace", fields.Namespace)
	q.Add("locale", fields.Locale)
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNTalentTreeNodes(ctx context.Context, fields *TalentTreeNodesFields)(any,error){

obj, err := StringTalentTreeNodes(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&TalentTreeNodesResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var TalentTreeNodes = CNTalentTreeNodes
/*func BNetTalentTreeNodes(ctx context.Context, fields *TalentTreeNodesFields)(any,error){

obj ,err := CNTalentTreeNodes(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*TalentTreeNodesResponse).ToBNet(),nil
}*/

 
//==============================================================================================

type TalentsIndexFields struct{
	Namespace string//The namespace to use to locate this document.
	Locale string//The locale to reflect in localized data.
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func TalentsIndexField(input *TalentsIndexFields) *TalentsIndexFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/data/wow/talent/index",
//			CnRegion:false ,
//}
//return input
//}


//TalentsIndex Returns an index of talents.
//
//@see: /data/wow/talent/index
func StringTalentsIndex(ctx context.Context, fields *TalentsIndexFields)(string,error){
	if fields == nil {
		fields = &TalentsIndexFields{}
	}

	func(input *TalentsIndexFields) {
	
if input.Namespace==""{
input.Namespace = "static-us"
}

	
if input.Locale==""{
input.Locale = "en_US"
}

	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/data/wow/talent/index",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("namespace", fields.Namespace)
	q.Add("locale", fields.Locale)
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNTalentsIndex(ctx context.Context, fields *TalentsIndexFields)(any,error){

obj, err := StringTalentsIndex(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&TalentsIndexResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var TalentsIndex = CNTalentsIndex
/*func BNetTalentsIndex(ctx context.Context, fields *TalentsIndexFields)(any,error){

obj ,err := CNTalentsIndex(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*TalentsIndexResponse).ToBNet(),nil
}*/

 
//==============================================================================================

type TalentFields struct{
	TalentId int//The ID of the talent.
	Namespace string//The namespace to use to locate this document.
	Locale string//The locale to reflect in localized data.
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func TalentField(input *TalentFields) *TalentFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/data/wow/talent/{talentId}",
//			CnRegion:false ,
//}
//return input
//}


//Talent Returns a talent by ID.
//
//@see: /data/wow/talent/{talentId}
func StringTalent(ctx context.Context, fields *TalentFields)(string,error){
	if fields == nil {
		fields = &TalentFields{}
	}

	func(input *TalentFields) {
	
if input.TalentId==0{
input.TalentId = 117163
}
	
	
if input.Namespace==""{
input.Namespace = "static-us"
}

	
if input.Locale==""{
input.Locale = "en_US"
}

	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/data/wow/talent/{talentId}",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("talentId", strconv.Itoa(fields.TalentId))
	q.Add("namespace", fields.Namespace)
	q.Add("locale", fields.Locale)
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNTalent(ctx context.Context, fields *TalentFields)(any,error){

obj, err := StringTalent(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&TalentResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var Talent = CNTalent
/*func BNetTalent(ctx context.Context, fields *TalentFields)(any,error){

obj ,err := CNTalent(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*TalentResponse).ToBNet(),nil
}*/

 
//==============================================================================================

type PvPTalentsIndexFields struct{
	Namespace string//The namespace to use to locate this document.
	Locale string//The locale to reflect in localized data.
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func PvPTalentsIndexField(input *PvPTalentsIndexFields) *PvPTalentsIndexFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/data/wow/pvp-talent/index",
//			CnRegion:false ,
//}
//return input
//}


//PvPTalentsIndex Returns an index of PvP talents.
//
//@see: /data/wow/pvp-talent/index
func StringPvPTalentsIndex(ctx context.Context, fields *PvPTalentsIndexFields)(string,error){
	if fields == nil {
		fields = &PvPTalentsIndexFields{}
	}

	func(input *PvPTalentsIndexFields) {
	
if input.Namespace==""{
input.Namespace = "static-us"
}

	
if input.Locale==""{
input.Locale = "en_US"
}

	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/data/wow/pvp-talent/index",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("namespace", fields.Namespace)
	q.Add("locale", fields.Locale)
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNPvPTalentsIndex(ctx context.Context, fields *PvPTalentsIndexFields)(any,error){

obj, err := StringPvPTalentsIndex(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&PvPTalentsIndexResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var PvPTalentsIndex = CNPvPTalentsIndex
/*func BNetPvPTalentsIndex(ctx context.Context, fields *PvPTalentsIndexFields)(any,error){

obj ,err := CNPvPTalentsIndex(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*PvPTalentsIndexResponse).ToBNet(),nil
}*/

 
//==============================================================================================

type PvPTalentFields struct{
	PvpTalentId int//The ID of the PvP talent.
	Namespace string//The namespace to use to locate this document.
	Locale string//The locale to reflect in localized data.
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func PvPTalentField(input *PvPTalentFields) *PvPTalentFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/data/wow/pvp-talent/{pvpTalentId}",
//			CnRegion:false ,
//}
//return input
//}


//PvPTalent Returns a PvP talent by ID.
//
//@see: /data/wow/pvp-talent/{pvpTalentId}
func StringPvPTalent(ctx context.Context, fields *PvPTalentFields)(string,error){
	if fields == nil {
		fields = &PvPTalentFields{}
	}

	func(input *PvPTalentFields) {
	
if input.PvpTalentId==0{
input.PvpTalentId = 40
}
	
	
if input.Namespace==""{
input.Namespace = "static-us"
}

	
if input.Locale==""{
input.Locale = "en_US"
}

	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/data/wow/pvp-talent/{pvpTalentId}",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("pvpTalentId", strconv.Itoa(fields.PvpTalentId))
	q.Add("namespace", fields.Namespace)
	q.Add("locale", fields.Locale)
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNPvPTalent(ctx context.Context, fields *PvPTalentFields)(any,error){

obj, err := StringPvPTalent(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&PvPTalentResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var PvPTalent = CNPvPTalent
/*func BNetPvPTalent(ctx context.Context, fields *PvPTalentFields)(any,error){

obj ,err := CNPvPTalent(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*PvPTalentResponse).ToBNet(),nil
}*/


