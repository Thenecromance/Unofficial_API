package D3_D3
// AUTOMATICALLY GENERATED FILE, DO NOT EDIT
// This file is generated by tools/updater
// Author: @Thenecromance 
import (
	"Unofficial_API/api/Authentication"
	"Unofficial_API/utils"
	"context"
	"encoding/json"
	"io"
	"net/http"
	"strconv"
)

 
//==============================================================================================

type SeasonIndexFields struct{
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func SeasonIndexField(input *SeasonIndexFields) *SeasonIndexFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/data/d3/season/",
//			CnRegion:false ,
//}
//return input
//}


//SeasonIndex Returns an index of available seasons.
//
//@see: /data/d3/season/
func StringSeasonIndex(ctx context.Context, fields *SeasonIndexFields)(string,error){
	if fields == nil {
		fields = &SeasonIndexFields{}
	}

	func(input *SeasonIndexFields) {
	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/data/d3/season/",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNSeasonIndex(ctx context.Context, fields *SeasonIndexFields)(any,error){

obj, err := StringSeasonIndex(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&SeasonIndexResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var SeasonIndex = CNSeasonIndex
/*func BNetSeasonIndex(ctx context.Context, fields *SeasonIndexFields)(any,error){

obj ,err := CNSeasonIndex(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*SeasonIndexResponse).ToBNet(),nil
}*/

 
//==============================================================================================

type SeasonFields struct{
	Id int//The season for the leaderboard list; get a list of seasons with `GET /data/d3/season/`.
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func SeasonField(input *SeasonFields) *SeasonFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/data/d3/season/:id",
//			CnRegion:false ,
//}
//return input
//}


//Season Returns a leaderboard list for the specified season.
//
//@see: /data/d3/season/:id
func StringSeason(ctx context.Context, fields *SeasonFields)(string,error){
	if fields == nil {
		fields = &SeasonFields{}
	}

	func(input *SeasonFields) {
	
if input.Id==0{
input.Id = 1
}
	
	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/data/d3/season/:id",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("id", strconv.Itoa(fields.Id))
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNSeason(ctx context.Context, fields *SeasonFields)(any,error){

obj, err := StringSeason(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&SeasonResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var Season = CNSeason
/*func BNetSeason(ctx context.Context, fields *SeasonFields)(any,error){

obj ,err := CNSeason(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*SeasonResponse).ToBNet(),nil
}*/

 
//==============================================================================================

type SeasonLeaderboardFields struct{
	Id int//The season for the leaderboard; get a list of seasons with `GET /data/d3/season/`.
	Leaderboard string//The leaderboard to retrieve; get a list of  leaderboards with `GET /data/d3/season/:id`.
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func SeasonLeaderboardField(input *SeasonLeaderboardFields) *SeasonLeaderboardFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/data/d3/season/:id/leaderboard/:leaderboard",
//			CnRegion:false ,
//}
//return input
//}


//SeasonLeaderboard Returns a the specified leaderboard for the specified season.
//
//@see: /data/d3/season/:id/leaderboard/:leaderboard
func StringSeasonLeaderboard(ctx context.Context, fields *SeasonLeaderboardFields)(string,error){
	if fields == nil {
		fields = &SeasonLeaderboardFields{}
	}

	func(input *SeasonLeaderboardFields) {
	
if input.Id==0{
input.Id = 1
}
	
	
if input.Leaderboard==""{
input.Leaderboard = "achievement-points"
}

	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/data/d3/season/:id/leaderboard/:leaderboard",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("id", strconv.Itoa(fields.Id))
	q.Add("leaderboard", fields.Leaderboard)
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNSeasonLeaderboard(ctx context.Context, fields *SeasonLeaderboardFields)(any,error){

obj, err := StringSeasonLeaderboard(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&SeasonLeaderboardResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var SeasonLeaderboard = CNSeasonLeaderboard
/*func BNetSeasonLeaderboard(ctx context.Context, fields *SeasonLeaderboardFields)(any,error){

obj ,err := CNSeasonLeaderboard(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*SeasonLeaderboardResponse).ToBNet(),nil
}*/

 
//==============================================================================================

type EraIndexFields struct{
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func EraIndexField(input *EraIndexFields) *EraIndexFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/data/d3/era/",
//			CnRegion:false ,
//}
//return input
//}


//EraIndex Returns an index of available eras.
//
//@see: /data/d3/era/
func StringEraIndex(ctx context.Context, fields *EraIndexFields)(string,error){
	if fields == nil {
		fields = &EraIndexFields{}
	}

	func(input *EraIndexFields) {
	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/data/d3/era/",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNEraIndex(ctx context.Context, fields *EraIndexFields)(any,error){

obj, err := StringEraIndex(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&EraIndexResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var EraIndex = CNEraIndex
/*func BNetEraIndex(ctx context.Context, fields *EraIndexFields)(any,error){

obj ,err := CNEraIndex(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*EraIndexResponse).ToBNet(),nil
}*/

 
//==============================================================================================

type EraFields struct{
	Id int//The era to retrieve; get a list of eras with `GET data/d3/era/`.
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func EraField(input *EraFields) *EraFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/data/d3/era/:id",
//			CnRegion:false ,
//}
//return input
//}


//Era Returns a leaderboard list for a particular era.
//
//@see: /data/d3/era/:id
func StringEra(ctx context.Context, fields *EraFields)(string,error){
	if fields == nil {
		fields = &EraFields{}
	}

	func(input *EraFields) {
	
if input.Id==0{
input.Id = 1
}
	
	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/data/d3/era/:id",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("id", strconv.Itoa(fields.Id))
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNEra(ctx context.Context, fields *EraFields)(any,error){

obj, err := StringEra(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&EraResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var Era = CNEra
/*func BNetEra(ctx context.Context, fields *EraFields)(any,error){

obj ,err := CNEra(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*EraResponse).ToBNet(),nil
}*/

 
//==============================================================================================

type EraLeaderboardFields struct{
	Id int//The era for the leaderboard; get a list of eras with `GET /data/d3/era/`.
	Leaderboard string//The leaderboard to retrieve; get a list of leaderboards with `GET /data/d3/era/:id`.
	
	ExtraFields map[any]any // extra fields
	utils.RequestMethod
}

//func EraLeaderboardField(input *EraLeaderboardFields) *EraLeaderboardFields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "GET",
//			Path: "/data/d3/era/:id/leaderboard/:leaderboard",
//			CnRegion:false ,
//}
//return input
//}


//EraLeaderboard Returns the specified leaderboard for the specified era.
//
//@see: /data/d3/era/:id/leaderboard/:leaderboard
func StringEraLeaderboard(ctx context.Context, fields *EraLeaderboardFields)(string,error){
	if fields == nil {
		fields = &EraLeaderboardFields{}
	}

	func(input *EraLeaderboardFields) {
	
if input.Id==0{
input.Id = 1
}
	
	
if input.Leaderboard==""{
input.Leaderboard = "rift-barbarian"
}

	
		input.RequestMethod = utils.RequestMethod{
			Methods: "GET",
			Path: "/data/d3/era/:id/leaderboard/:leaderboard",
			CnRegion:false ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)
	
	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	q.Add("id", strconv.Itoa(fields.Id))
	q.Add("leaderboard", fields.Leaderboard)
	
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CNEraLeaderboard(ctx context.Context, fields *EraLeaderboardFields)(any,error){

obj, err := StringEraLeaderboard(ctx,fields)
if err != nil {
		return nil,err
	}
resp :=&EraLeaderboardResponse{}
err = json.Unmarshal([]byte(obj), resp )
	if err != nil {
		return nil,err
	}

return resp,nil 
}

var EraLeaderboard = CNEraLeaderboard
/*func BNetEraLeaderboard(ctx context.Context, fields *EraLeaderboardFields)(any,error){

obj ,err := CNEraLeaderboard(ctx,fields)
if err != nil {
	return nil,err
}


return obj.(*EraLeaderboardResponse).ToBNet(),nil
}*/


