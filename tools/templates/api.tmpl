package {{.PkgName}}_{{.ApiGroupName}}
// AUTOMATICALLY GENERATED FILE, DO NOT EDIT
// This file is generated by tools/updater
// Author: @Thenecromance
import (
	"Unofficial_API/api/Authentication"
	"Unofficial_API/utils"
	"context"
	"encoding/json"
	"io"
	"net/http"
	"strconv"
)

{{range .Apis}}
//==============================================================================================

type {{.Name}}Fields struct{
	{{range .Params}}{{.Name}} {{.Type}}//{{.Description}}
	{{end}}
	ExtraFields map[any]any // extra fields
	CN *utils.CNRequestMethod
	utils.RequestMethod
}

//func {{.Name}}Field(input *{{.Name}}Fields) *{{.Name}}Fields {
//input.RequestMethod = utils.RequestMethod{
//			Methods: "{{.Method}}",
//			Path: "{{.Path}}",
//			CnRegion:{{.CnRegion}} ,
//}
//return input
//}



func String{{.Name}}(ctx context.Context, fields *{{.Name}}Fields)(string,error){
	if fields == nil {
		fields = &{{.Name}}Fields{}
	}

	func(input *{{.Name}}Fields) {
	{{range .Params}}{{if eq .Type "int"}}
    if input.{{.Name}}==0{
        input.{{.Name}} = {{.DefaultValue}}
    }
	{{else}}
    if input.{{.Name}}==""{
        input.{{.Name}} = "{{.DefaultValue}}"
    }
{{end}}
	{{end}}
		input.RequestMethod = utils.RequestMethod{
			Methods: "{{.Method}}",
			Path: "{{.Path}}",
			CnRegion:{{.CnRegion}} ,
		}
	}(fields)
	cli := http.Client{}
	req, err := http.NewRequestWithContext(
		ctx,
		fields.Methods,
		"https://us.api.blizzard.com"+fields.Path,
		nil)

	if err != nil {
		return "", err
	}
	req.Header.Add("Authorization", "Bearer "+Authentication.GetToken())
	q := req.URL.Query()
	{{range .Params}}q.Add("{{.ParamName}}", {{if eq .Type "int"}}strconv.Itoa(fields.{{.Name}}){{else}}fields.{{.Name}}{{end}})
	{{end}}
	req.URL.RawQuery = q.Encode()

	resp, err := cli.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	responseBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(responseBytes), nil
}

func CN{{.Name}}(ctx context.Context, fields *{{.Name}}Fields)(any,error){

    obj, err := cnString{{.Name}}(ctx,fields)
    if err != nil {
    		return nil,err
    	}
    var resp struct{
        Code int `json:"code"`
        Message string `json:"message"`
        Data *{{.Name}}Response `json:"data"`
    }

    err = json.Unmarshal([]byte(obj), &resp )
    	if err != nil {
    		return nil,err
    	}

    return resp.Data,nil
}

func cnString{{.Name}}(ctx context.Context, fields *{{.Name}}Fields)(string,error){
	return "" , ApiError.ErrorInDevelopment
	token := internal.TryToGetToken(fields.CN.RealmSlug, fields.CN.Name)
	if token == ""{
		return "",ApiError.ErrorNoToken
	}
	return 	client.GET("https://webapi.blizzard.cn/wow-armory-server/api/do", "api", "",  "token",token)
}



func bridge{{.Name}}(ctx context.Context, fields *{{.Name}}Fields)(any,error){


     if fields.CN !=nil { // if no CN request parameters, use portal request instead
        obj ,err := CN{{.Name}}(ctx,fields)
             if err != nil {
             	return nil,err
             }
             return obj.(*{{.Name}}Response).ToBNet(),nil
     }
   obj ,err := String{{.Name}}(ctx,fields)
           if err != nil {
           return nil, err
           }
           resp:= &BNet{{.Name}}Response{}
           err = json.Unmarshal([]byte(obj), &resp )
           if err != nil {
           	return nil,err
           }
           return resp, nil


}

//{{.Description}}
//
//@see: {{.Path}}
var {{.Name}} = bridge{{.Name}}
{{end}}